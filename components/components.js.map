{"version":3,"file":"components.js","sources":["texgen/operations/basic.js","texgen/operations/advanced.js","texgen/utils/mixColors.js","texgen/utils/wrap.js","texgen/utils/clamp.js","texgen/utils/distance.js","texgen/utils/smoothStep.js","texgen/programs/generators/noiseBase/hashRNG.js","texgen/programs/generators/celularNoiseBase/cellNoiseBase.js","texgen/utils/deg2rad.js","texgen/utils/bufferToCanvas.js","texgen-schema/getSchema.js","texgen-generator/getRef.js","texgen-generator/traverse.js","texgen-generator/getRandom.js","texgen-generator/getProgram.js","texgen-generator/getFeatures.js","texgen-recipe/recipeToBody.js","texgen-recipe/bodyToFunction.js","texgen-recipe/recipeToFunction.js","texgen-recipe/formatRecipe.js","texgen-recipe/componentOnIndex.js","texgen-recipe/componentToIndex.js","texgen-workers/workers.js","texgen/core/Buffer.js","texgen/core/Texture.js","texgen/core/Program.js","texgen/utils/ColorInterpolator.js","texgen/programs/generators/Number.js","texgen/programs/generators/SinX.js","texgen/programs/generators/SinY.js","texgen/programs/generators/Or.js","texgen/programs/generators/Xor.js","texgen/programs/generators/Rect.js","texgen/programs/generators/Circle.js","texgen/programs/generators/CheckerBoard.js","texgen/programs/generators/LinearGradient.js","texgen/programs/generators/RadialGradient.js","texgen/programs/generators/Noise.js","texgen/programs/generators/NoiseFractal.js","texgen/programs/generators/CellularNoise.js","texgen/programs/generators/CellularFractal.js","texgen/programs/generators/VoronoiNoise.js","texgen/programs/generators/VoronoiFractal.js","texgen/programs/generators/simplexNoiseBase/FastSimplexNoise.js","texgen/programs/generators/SimplexNoise.js","texgen/programs/filters/Abs.js","texgen/programs/filters/Copy.js","texgen/programs/filters/Convolution.js","texgen/programs/filters/Distort.js","texgen/programs/filters/GradientMap.js","texgen/programs/filters/Grayscale.js","texgen/programs/filters/Normalize.js","texgen/programs/filters/Pixelate.js","texgen/programs/filters/Posterize.js","texgen/programs/filters/SineDistort.js","texgen/programs/filters/Transform.js","texgen/programs/filters/Twirl.js","texgen/programs/mixers/PutTexture.js","texgen/programs/index.js","texgen/index.js","../node_modules/d3-random/src/uniform.js","texgen-generator/colors.js","texgen-recipe/params.js","texgen-samples/index.js"],"sourcesContent":["export function set(x, y) {\r\n    return y;\r\n}\r\n\r\nexport function add(x, y) {\r\n    return x + y;\r\n}\r\n\r\nexport function sub(x, y) {\r\n    return x - y;\r\n}\r\n\r\nexport function mul(x, y) {\r\n    return x * y;\r\n}\r\n\r\nexport function div(x, y) {\r\n    return x / y;\r\n}\r\n\r\nexport function and(x, y) {\r\n    return x & y;\r\n}\r\n\r\nexport function xor(x, y) {\r\n    return x ^ y;\r\n}\r\n\r\nexport function min(x, y) {\r\n    return Math.min(x, y);\r\n}\r\n\r\nexport function max(x, y) {\r\n    return Math.max(x, y);\r\n}\r\n","export function average(a, b) {\r\n    return (a + b) / 2;\r\n}\r\n\r\nexport function screen(a, b) {\r\n    return 1 - (1 - a) * (1 - b);\r\n}\r\n\r\nexport function overlay(a, b) {\r\n    return (b < .5)\r\n        ? (2 * a * b)\r\n        : (1 - 2 * (1 - a) * (1 - b));\r\n}\r\n\r\nexport function linearBurn(a, b) {\r\n    return a + b - 1;\r\n}\r\n\r\nexport function colorBurn(a, b) {\r\n    return (b === 0) ? b : (1 - (1 - a) / b);\r\n}\r\n\r\nexport function colorDodge(a, b) {\r\n    return (b >= 1) ? b : (a / (1 - b));\r\n}\r\n\r\nexport function difference(a, b) {\r\n    return Math.abs(a - b);\r\n}\r\n\r\nexport function exclusion(a, b) {\r\n    return .5 - 2 * (a - .5) * (b - .5);\r\n}\r\n\r\nexport function softLight(a, b) {\r\n    return (b < .5)\r\n        ? (2 * ((a / 2) + .25)) * b\r\n        : (1 - (2 * (1 - ((a / 2) + .25)) * (1 - b)));\r\n}\r\nexport function hardLight(a, b) {\r\n    return (a < .5)\r\n        ? (2 * b * a)\r\n        : (1 - 2 * (1 - b) * (1 - a));\r\n}\r\n\r\nexport function vividLight(a, b) {\r\n    return (a > .5)\r\n        ? (1 - (1 - b) / (2 * (a - .5)))\r\n        : (b / (1 - 2 * a));\r\n}\r\nexport function linearLight(a, b) {\r\n    return (b > 0.5)\r\n        ? (a + 2 * (b - .5))\r\n        : (a + 2 * b - 1);\r\n}\r\n\r\nexport function pinLight(a, b) {\r\n    return (b > 0.5)\r\n        ? Math.max(a, 2 * (b - .5))\r\n        : Math.min(a, 2 * b);\r\n}\r\n","export function mixColors(c1, c2, delta) {\r\n    return [\r\n        c1[0] * ( 1 - delta ) + c2[0] * delta,\r\n        c1[1] * ( 1 - delta ) + c2[1] * delta,\r\n        c1[2] * ( 1 - delta ) + c2[2] * delta\r\n        // c1[3] * ( 1 - delta ) + c2[3] * delta\r\n    ];\r\n}\r\n","export function wrap(value, min, max) {\r\n    const v = value - min;\r\n    const r = max - min;\r\n\r\n    return ( ( r + v % r ) % r ) + min;\r\n}\r\n\r\nexport function mirroredWrap(value, min, max) {\r\n    let v = value - min;\r\n    const r = ( max - min ) * 2;\r\n\r\n    v = ( r + v % r ) % r;\r\n\r\n    if (v > max - min) {\r\n        return ( r - v ) + min;\r\n    } else {\r\n        return v + min;\r\n    }\r\n}\r\n","export function clamp(value, min, max) {\r\n    return Math.min(Math.max(value, min), max);\r\n}\r\n","export function distance(x0, y0, x1, y1) {\r\n    const dx = x1 - x0, dy = y1 - y0;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n","import {clamp} from './clamp';\r\n\r\nexport function smoothStep(edge0, edge1, x) {\r\n    // Scale, bias and saturate x to 0..1 range\r\n    let xx = clamp(( x - edge0 ) / ( edge1 - edge0 ), 0, 1);\r\n\r\n    // Evaluate polynomial\r\n    return xx * xx * ( 3 - 2 * xx );\r\n}\r\n","export function hashRNG(seed, x, y) {\r\n    const s = ( Math.abs(seed % 2147483648) === 0 ) ? 1 : seed;\r\n    let a = ( ( s * ( x + 1 ) * 777 ) ^ ( s * ( y + 1 ) * 123 ) ) % 2147483647;\r\n\r\n    a = (a ^ 61) ^ (a >> 16);\r\n    a = a + (a << 3);\r\n    a = a ^ (a >> 4);\r\n    a = a * 0x27d4eb2d;\r\n    a = a ^ (a >> 15);\r\n    a = a / 2147483647;\r\n\r\n    return a;\r\n}\r\n","import {hashRNG} from '../noiseBase/hashRNG';\r\n\r\nexport function cellNoiseBase(x, y, seed, density, weight) {\r\n    let qx, qy, rx, ry, w, px, py, dx, dy;\r\n    let dist, value;\r\n    let shortest = Infinity;\r\n    density = Math.abs(density);\r\n\r\n    for (let sx = -2; sx <= 2; sx++) {\r\n        for (let sy = -2; sy <= 2; sy++) {\r\n            qx = Math.ceil(x / density) + sx;\r\n            qy = Math.ceil(y / density) + sy;\r\n\r\n            rx = hashRNG(seed, qx, qy);\r\n            ry = hashRNG(seed * 2, qx, qy);\r\n            w = ( weight > 0 ) ? 1 + hashRNG(seed * 3, qx, qy) * weight : 1;\r\n\r\n            px = ( rx + qx ) * density;\r\n            py = ( ry + qy ) * density;\r\n\r\n            dx = Math.abs(px - x);\r\n            dy = Math.abs(py - y);\r\n\r\n            dist = ( dx * dx + dy * dy ) * w;\r\n\r\n            if (dist < shortest) {\r\n                shortest = dist;\r\n                value = rx;\r\n            }\r\n        }\r\n    }\r\n\r\n    return {dist: Math.sqrt(shortest), value: value};\r\n}\r\n","const dr = Math.PI / 180;\r\n\r\nexport function deg2rad(deg) {\r\n    return deg * dr;\r\n}\r\n","export function bufferToCanvas(buffer, width, height, canvas = null) {\r\n    const can = canvas || document.createElement('canvas');\r\n    can.width = width;\r\n    can.height = height;\r\n    const ctx = can.getContext('2d');\r\n    const imageData = ctx.getImageData(0, 0, width, height);\r\n    const data = imageData.data;\r\n    const heap = new Uint8Array(buffer);\r\n    const last = heap.length;\r\n    let i = 0;\r\n\r\n    while (i < last) {\r\n        data[i] = heap[i++];\r\n    }\r\n\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    return can;\r\n}\r\n","let schema = null;\r\n\r\nimport * as TG from '../texgen';\r\n\r\nexport function getSchema() {\r\n    if (schema) {\r\n        return schema;\r\n    }\r\n\r\n    const s = {\r\n        type: \"object\",\r\n        properties: {\r\n            render: {\r\n                $ref: \"#/definitions/texture\"\r\n            }\r\n        },\r\n        required: [\r\n            \"render\"\r\n        ],\r\n        definitions: {\r\n            operation: {},\r\n            texture: {\r\n                type: \"array\",\r\n                minItems: 3,\r\n                maxItems: 7,\r\n                items: {\r\n                    type: \"object\",\r\n                    properties: {\r\n                        operation: {\r\n                            $ref: \"#/definitions/operation\"\r\n                        },\r\n                        tint: {\r\n                            $ref: \"#/definitions/tint\"\r\n                        },\r\n                        program: {\r\n                            anyOf: []\r\n                        }\r\n                    },\r\n                    required: [\r\n                        \"operation\",\r\n                        \"program\"\r\n                    ]\r\n                }\r\n\r\n            },\r\n            tint: {\r\n                type: \"array\",\r\n                minItems: 3,\r\n                maxItems: 4,\r\n                items: {\r\n                    type: \"number\",\r\n                    minimum: 0,\r\n                    maximum: 1,\r\n                    'default': 0.5\r\n                }\r\n            },\r\n            color: {\r\n                type: \"array\",\r\n                minItems: 3,\r\n                maxItems: 3,\r\n                items: {\r\n                    type: \"number\",\r\n                    minimum: 0,\r\n                    maximum: 1,\r\n                    'default': 0.5\r\n                }\r\n            },\r\n            point: {\r\n                type: \"array\",\r\n                minItems: 2,\r\n                maxItems: 8,\r\n                items: {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            type: \"number\",\r\n                            minimum: 0,\r\n                            maximum: 1,\r\n                            'default': 0.5\r\n                        },\r\n                        {\r\n                            $ref: \"#/definitions/color\"\r\n                        }\r\n                    ]\r\n                },\r\n                'default': [[0, [0, 0, 0]], [.4, [1, 1, 1]], [.6, [1, 1, 1]], [1, [0, 0, 0]]]\r\n            },\r\n            interpolation: {\r\n                'enum': [\r\n                    0,\r\n                    1,\r\n                    2\r\n                ],\r\n                'default': 1\r\n            }\r\n        }\r\n    };\r\n\r\n    s.definitions.operation.enum = Object.keys(TG.Operations);\r\n\r\n    let r = s.definitions.texture.items.properties.program.anyOf;\r\n\r\n    addPrograms(s, 'generators', TG.Programs.Generators, r, TG);\r\n    addPrograms(s, 'filters', TG.Programs.Filters, r, TG);\r\n    addPrograms(s, 'mixers', TG.Programs.Mixers, r, TG);\r\n\r\n    schema = s;\r\n\r\n    return s;\r\n}\r\n\r\nfunction addPrograms(s, n, l, r, TG) {\r\n    Object.keys(l).forEach((k) => {\r\n        r.push({\r\n            $ref: '#/definitions/' + n + '/definitions/' + k\r\n        });\r\n\r\n        s.definitions[n] = s.definitions[n] || {definitions: {}};\r\n\r\n        let o = s.definitions[n].definitions[k] = {\r\n            properties: {\r\n                type: {\r\n                    enum: [k]\r\n                }\r\n            },\r\n            required: ['type']\r\n        };\r\n\r\n        if (l[k].params) {\r\n            Object.keys(l[k].params).forEach((p) => {\r\n                let q = o.properties[p] = {};\r\n                let t = l[k].params[p];\r\n                let pt = {\r\n                    isArray: Array.isArray(t.val),\r\n                    type: t.type || 0,\r\n                    min: !isNaN(t.min) ? t.min : -256,\r\n                    max: !isNaN(t.max) ? t.max : 256,\r\n                    length: Array.isArray(t.val) ? t.val.length : 1,\r\n                    val: t.val\r\n                };\r\n\r\n                if (pt.isArray) {\r\n                    q.type = 'array';\r\n                    q.items = {\r\n                        type: pt.type ? 'number' : 'integer',\r\n                        minimum: pt.min,\r\n                        maximum: pt.max\r\n                    };\r\n\r\n                    q.minItems = pt.length;\r\n                    q.maxItems = pt.length;\r\n                } else if (pt.type === TG.Type.BOOLEAN) {\r\n                    q.type = 'boolean';\r\n                } else if (pt.type === TG.Type.COLOR_POINT) {\r\n                    q.$ref = '#/definitions/point';\r\n                } else if (pt.type === TG.Type.INTERPOLATION) {\r\n                    q.$ref = '#/definitions/interpolation';\r\n                } else if (pt.type === TG.Type.NUMBER) {\r\n                    q.type = 'number';\r\n                    q.minimum = pt.min;\r\n                    q.maximum = pt.max;\r\n                } else if (pt.type === TG.Type.INT) {\r\n                    q.type = 'integer';\r\n                    q.minimum = pt.min;\r\n                    q.maximum = pt.max;\r\n                }\r\n\r\n                q.default = pt.val;\r\n            })\r\n        }\r\n\r\n        if (k === 'PutTexture') {\r\n            o.properties.texture = {\r\n                $ref: \"#/definitions/texture\"\r\n            };\r\n        }\r\n    });\r\n}\r\n","export function getRef($ref, schema) {\r\n    let parts = $ref.slice(2).split('/');\r\n    let x = schema;\r\n\r\n    parts.forEach((part) => {\r\n        x = x[part];\r\n    });\r\n\r\n    return x;\r\n}\r\n","import {getRef} from \"./getRef\";\r\nimport {randomUniform} from \"d3-random\";\r\n\r\nexport function traverse(current, root = null) {\r\n    let c = current;\r\n    let r = root || current;\r\n    let result = {};\r\n\r\n    if (!c) {\r\n        throw new Error();\r\n    }\r\n\r\n    if (c.$ref) {\r\n        c = getRef(c.$ref, r);\r\n    }\r\n\r\n    // if (c.default) {\r\n    //     return c.default;\r\n    // }\r\n\r\n    if (c.enum) {\r\n        return c.enum[Math.floor(randomUniform(c.enum.length)())];\r\n    }\r\n\r\n    if (c.type === 'number') {\r\n        return parseFloat(randomUniform(c.minimum || Number.MIN_VALUE, c.maximum || Number.MAX_VALUE)().toPrecision(2));\r\n        // return rand(c.minimum, c.default, c.maximum);\r\n    } else if (c.type === 'integer') {\r\n        return Math.floor(randomUniform(c.minimum || Number.MIN_VALUE, c.maximum || Number.MAX_VALUE)());\r\n        // return  Math.floor(rand(c.minimum, c.default, c.maximum));\r\n    } else if (c.type === 'boolean') {\r\n        return Math.floor(randomUniform(2)()) === 1;\r\n    } else if (c.type === 'array') {\r\n        let items = c.items.length\r\n        || Math.min((c.maxItems || 8), Math.floor(randomUniform(c.minItems || 1, (c.maxItems || 8) + 1)()));\r\n\r\n        result = [];\r\n\r\n        for (let i = 0; i < items; i++) {\r\n            let item = c.items.length ? c.items[i] : c.items;\r\n            let value = traverse(item, r);\r\n\r\n            result.push(value);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    if (c.anyOf) {\r\n        let picked = c.anyOf[Math.floor(randomUniform(c.anyOf.length)())];\r\n        return traverse(picked, r);\r\n    }\r\n\r\n    if (c.properties) {\r\n        Object.keys(c.properties).forEach((prop) => {\r\n            result[prop] = traverse(c.properties[prop], r);\r\n        });\r\n    }\r\n\r\n    return result;\r\n}\r\n","import {getSchema} from '../texgen-schema';\r\nimport {traverse} from \"./traverse\";\r\n\r\nexport function getRandom() {\r\n    var r = traverse(getSchema());\r\n\r\n    if (!TG.Programs.Generators[r.render[0].program.type]) {\r\n        r.render[0].program = {\r\n            type: 'Number'\r\n        }\r\n    }\r\n\r\n    return r;\r\n}\r\n","import {getRef} from \"./getRef\";\r\n\r\nexport function getProgram(tt, schema) {\r\n    let pr = {\r\n        type: tt.properties['type'].enum[0]\r\n    };\r\n\r\n    Object.keys(tt.properties)\r\n        .filter(function (p) {\r\n            return p !== 'type'\r\n        })\r\n        .forEach(function (p) {\r\n            let c = tt.properties[p];\r\n\r\n            if (c.$ref) {\r\n                c = getRef(c.$ref, schema);\r\n            }\r\n\r\n            if (c.default !== undefined) {\r\n                pr[p] = c.default;\r\n            }\r\n        });\r\n\r\n    return pr;\r\n}\r\n","import {getSchema} from '../texgen-schema/getSchema';\r\nimport {colors} from './colors';\r\nimport {getProgram} from './getProgram';\r\nimport * as TG from '../texgen';\r\n\r\nconst baseId = 1;\r\nconst mixId = 3;\r\n\r\nexport function getFeatures() {\r\n    const schema = getSchema();\r\n    let ret = [];\r\n    addGenerators(ret, schema.definitions['generators'].definitions, schema);\r\n    addFilters(ret, {...ret[baseId].render[0], ...{tint: [1, 1, 1]}}, schema.definitions['filters'].definitions, schema);\r\n    addMixers(ret, {...ret[baseId].render[0]}, {...ret[mixId].render[0]});\r\n    addOperations(ret, {...ret[baseId].render[0], ...{tint: [1, 1, 0.5]}}, {...ret[mixId].render[0]}, schema.definitions['operation'].enum);\r\n    addAlphas(ret, {...ret[baseId].render[0], ...{tint: [1, 1, 0.5]}}, {...ret[mixId].render[0]});\r\n    return ret;\r\n}\r\n\r\nfunction addGenerators(ret, defs, schema) {\r\n    let color = 0;\r\n    let keys = Object.keys(defs);\r\n    keys.forEach(function (k) {\r\n        let tt = defs[k];\r\n        let pr = getProgram(tt, schema);\r\n\r\n        ret.push({\r\n            title: k,\r\n            group: 'Generators',\r\n            render: [\r\n                {\r\n                    tint: colors[color++ % colors.length],\r\n                    operation: 'set',\r\n                    program: pr\r\n                }\r\n            ]\r\n        });\r\n\r\n\r\n        if (TG[k] && TG[k].examples) {\r\n            TG[k].examples.forEach(function (e, i) {\r\n                let pr = getProgram(tt, schema);\r\n\r\n                Object.keys(e).forEach(function (k) {\r\n                    pr[k] = e[k];\r\n                });\r\n\r\n                ret.push({\r\n                    title: k,\r\n                    subTitle: '#' + (i + 1),\r\n                    group: 'Generators',\r\n                    render: [\r\n                        {\r\n                            tint: colors[color++ % colors.length],\r\n                            operation: 'set',\r\n                            program: pr\r\n                        }\r\n                    ]\r\n                });\r\n            })\r\n        }\r\n    });\r\n}\r\n\r\nfunction addFilters(ret, base, defs, schema) {\r\n    const keys = Object.keys(defs);\r\n    keys.map(function (k) {\r\n        let tt = defs[k];\r\n        let pr = getProgram(tt, schema);\r\n\r\n        ret.push({\r\n            title: k,\r\n            group: 'Filters',\r\n            render: [\r\n                base,\r\n                {\r\n                    tint: [1, 1, 1],\r\n                    operation: 'set',\r\n                    program: pr\r\n                }\r\n            ]\r\n        });\r\n\r\n        if (TG[k] && TG[k].examples) {\r\n            TG[k].examples.forEach(function (e, i) {\r\n                let pr = getProgram(tt, schema);\r\n\r\n                Object.keys(e).forEach(function (k) {\r\n                    pr[k] = e[k];\r\n                });\r\n\r\n                ret.push({\r\n                    title: k,\r\n                    subTitle: '#' + (i + 1),\r\n                    group: 'Filters',\r\n                    render: [\r\n                        base,\r\n                        {\r\n                            tint: [1, 1, 1],\r\n                            operation: 'set',\r\n                            program: pr\r\n                        }\r\n                    ]\r\n                });\r\n            })\r\n        }\r\n    });\r\n}\r\n\r\nfunction addMixers(ret, base, mix) {\r\n    ret.push({\r\n        title: 'PutTexture',\r\n        group: 'Mixers',\r\n        render: [\r\n            base,\r\n            {\r\n                tint: [1, 1, 1],\r\n                operation: 'add',\r\n                program: {\r\n                    type: 'PutTexture',\r\n                    texture: [mix]\r\n                }\r\n            }\r\n        ]\r\n    });\r\n}\r\n\r\nfunction addOperations(ret, base, mix, keys) {\r\n    keys.map(function (k) {\r\n        ret.push({\r\n            title: k,\r\n            group: 'Operations',\r\n            render: [\r\n                base,\r\n                {\r\n                    tint: [1, .5, 1],\r\n                    operation: k,\r\n                    program: mix.program\r\n                }\r\n            ]\r\n        });\r\n    });\r\n}\r\n\r\nfunction addAlphas(ret, base, mix) {\r\n    [0, 0.25, 0.5, 0.75, 1].forEach(function (k) {\r\n        ret.push({\r\n            title: 'Alpha ' + k,\r\n            group: 'Alpha Blending',\r\n            render: [\r\n                base,\r\n                {\r\n                    tint: [1, .5, 1, k],\r\n                    operation: 'set',\r\n                    program: mix.program\r\n                }\r\n            ]\r\n        });\r\n    });\r\n}\r\n","import * as TG from '../texgen';\r\nimport {HEIGHT, WIDTH} from './params';\r\n\r\nexport function recipeToBody(formula, proportional = false, block = '') {\r\n    let r = ['new TG.Texture(' + WIDTH + ', ' + HEIGHT + ')'];\r\n    let CR = '\\n';\r\n    let SP = '  ';\r\n\r\n    (formula || []).forEach(function (part) {\r\n        if (!part) {\r\n            return;\r\n        }\r\n\r\n        let def = TG[part.program.type];\r\n\r\n        if (!def || part.$hide) {\r\n            return;\r\n        }\r\n\r\n        let g;\r\n\r\n        // if (part.program.type === 'PutTexture') {\r\n        //     g = 'new TG.' + part.program.type + '(' + recipeToBody(part.program.texture || [], proportional, SP + block) + ')';\r\n        // } else {\r\n        g = 'new TG.' + part.program.type + '()';\r\n        Object.keys(part.program)\r\n            .filter(function (p) {\r\n                return (p !== 'type') && def.params && def.params[p];\r\n            })\r\n            .forEach(function (p) {\r\n                if (p === 'point') {\r\n                    (part.program[p] || []).forEach(function (b) {\r\n                        g += CR + block + SP + SP + '.' + p + '(' + b[0] + ', [' + b[1].join(', ') + '])';\r\n                    });\r\n                } else if (p === 'texture') {\r\n                    g += CR + block + SP + SP + '.' + p + '(' + recipeToBody(part.program.texture || [], proportional, SP + SP + block) + ')';\r\n                } else {\r\n                    let a = getValue(part.program[p], TG[part.program.type].params && TG[part.program.type].params[p], proportional);\r\n                    g += CR + block + SP + SP + '.' + p + '(' + a + ')';\r\n                }\r\n            });\r\n        // }\r\n\r\n        g += CR + block + SP + SP + '.tint(' + part.tint.join(', ') + ')';\r\n\r\n        let s = '.' + (part.operation || 'set') + '(' + g + ')';\r\n\r\n        r.push(s);\r\n    });\r\n\r\n    return r.join(CR + block + SP) + (block ? '' : ';');\r\n}\r\n\r\nfunction getValue(val, param, proportional) {\r\n    if ((param.scale !== undefined) && proportional) {\r\n        return val.join ? val.map((v) => scaled(v, param.scale)).join(', ') : scaled(val, param.scale);\r\n    } else {\r\n        return val.join ? val.join(', ') : val;\r\n    }\r\n}\r\n\r\nfunction scaled(v, s) {\r\n    if (s) {\r\n        return (v / 256) + ('*' + WIDTH);\r\n    } else {\r\n        return (v * 256) + ('/' + WIDTH);\r\n    }\r\n}\r\n","import {HEIGHT, WIDTH} from './params';\r\n\r\nexport function bodyToFunction(body) {\r\n    return new Function(WIDTH, HEIGHT, 'return ' + body);\r\n}\r\n","import {recipeToBody} from './recipeToBody';\r\nimport {bodyToFunction} from './bodyToFunction';\r\n\r\nexport function recipeToFunction(formula) {\r\n    return bodyToFunction(recipeToBody(formula));\r\n}\r\n","export function formatRecipe(render, precision = 2, removeHide = false) {\r\n    const ret = [];\r\n\r\n    render.forEach((d) => {\r\n        const r = {\r\n            operation: d.operation\r\n        };\r\n\r\n        if (removeHide && d.$hide) {\r\n            return;\r\n        } else if (!removeHide && (d.$hide !== undefined)) {\r\n            r.$hide = d.$hide;\r\n        }\r\n\r\n        if (d.tint) {\r\n            r.tint = d.tint.map((n) => {\r\n                return formatNumber(n, precision);\r\n            });\r\n        }\r\n\r\n        r.program = {};\r\n\r\n        Object.keys(d.program).forEach((p) => {\r\n            var v = d.program[p];\r\n\r\n            if (Array.isArray(v)) {\r\n                v = v.map((n) => {\r\n                    if (typeof n === 'number') {\r\n                        return formatNumber(n, precision)\r\n                    } else {\r\n                        if (Array.isArray(n)) {\r\n                            return n.map((m) => {\r\n                                if (typeof m === 'number') {\r\n                                    return formatNumber(m, precision)\r\n                                } else {\r\n                                    return m;\r\n                                }\r\n                            });\r\n                        } else {\r\n                            return n;\r\n                        }\r\n                    }\r\n                });\r\n            } else if (typeof v === 'number') {\r\n                v = formatNumber(v, precision);\r\n            }\r\n\r\n            r.program[p] = v;\r\n        });\r\n\r\n        ret.push(r);\r\n    });\r\n\r\n    return ret;\r\n}\r\n\r\nfunction formatNumber(n, p) {\r\n    if (p) {\r\n        return parseFloat(n.toPrecision(p));\r\n    } else {\r\n        return n;\r\n    }\r\n}\r\n","import * as TG from '../texgen';\r\n\r\nexport function componentOnIndex(formula, index) {\r\n    let f = {...formula[index]};\r\n    f.operation = 'set';\r\n    delete f.$hide;\r\n\r\n    return !TG.Programs.Filters[f.program.type]\r\n        ? f.program.texture ? f.program.texture : [f]\r\n        : null;\r\n}\r\n","export function componentToIndex(formula, index) {\r\n    let f = [];\r\n\r\n    for (let j = 0; j <= index; j++) {\r\n        f.push(formula[j]);\r\n    }\r\n\r\n    return f;\r\n}\r\n","export function getWorkers(path, max) {\r\n    var workers = [];\r\n    var waiting = [];\r\n\r\n    function worker() {\r\n        var free = workers.filter(function (d) {\r\n            return d.free;\r\n        });\r\n\r\n        if (free.length) {\r\n            free[0].free = false;\r\n            return free[0];\r\n        }\r\n\r\n        var w = wrap(!(workers.length < max));\r\n        w.free = false;\r\n\r\n        if (workers.length < max) {\r\n            workers.push(w);\r\n        } else {\r\n            waiting.push(w);\r\n        }\r\n\r\n        return w;\r\n    }\r\n\r\n    function wrap(queue) {\r\n        var o = {\r\n            free: true,\r\n            worker: queue ? null : new Worker(path),\r\n            onmessage: null,\r\n            toBePosted: null,\r\n            postMessage: postMessage\r\n        };\r\n\r\n        function postMessage(msg) {\r\n            if (o.worker) {\r\n                o.worker.onmessage = function (e) {\r\n                    o.onmessage(e);\r\n\r\n                    setTimeout(function () {\r\n                        o.free = true;\r\n                        o.toBePosted = null;\r\n                        o.onmessage = null;\r\n\r\n                        if (waiting.length) {\r\n                            o.free = false;\r\n                            var w = waiting.shift();\r\n                            o.onmessage = w.onmessage;\r\n                            o.postMessage(w.toBePosted);\r\n                        }\r\n                    });\r\n                };\r\n                o.worker.postMessage(msg);\r\n            } else {\r\n                o.toBePosted = msg;\r\n            }\r\n        }\r\n\r\n        return o;\r\n    }\r\n\r\n    return {\r\n        worker: worker,\r\n        terminate: function () {\r\n            waiting = [];\r\n            workers.forEach(function (o) {\r\n                if(o.worker) {\r\n                    o.worker.onmessage = null;\r\n                    o.worker.terminate();\r\n                    o.worker = null;\r\n                }\r\n            });\r\n            workers = [];\r\n        }\r\n    }\r\n}\r\n","export class Buffer {\r\n    constructor(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.array = new Float32Array(width * height * 4);\r\n        this.color = new Float32Array(4);\r\n    }\r\n\r\n    copy(buffer) {\r\n        this.array.set(buffer.array);\r\n    }\r\n\r\n    getPixelNearest(x, y) {\r\n        let _x = Math.round(x);\r\n        let _y = Math.round(y);\r\n\r\n        while (_y >= this.height) _y -= this.height;\r\n        while (_y < 0) _y += this.height;\r\n        while (_x >= this.width) _x -= this.width;\r\n        while (_x < 0) _x += this.width;\r\n\r\n        const array = this.array;\r\n        const color = this.color;\r\n        const offset = _y * this.width * 4 + _x * 4;\r\n\r\n        color[0] = array[offset];\r\n        color[1] = array[offset + 1];\r\n        color[2] = array[offset + 2];\r\n\r\n        return this.color;\r\n    }\r\n\r\n    getPixelBilinear(x, y) {\r\n        const px = Math.floor(x);\r\n        const py = Math.floor(y);\r\n        const p0 = px + py * this.width;\r\n\r\n        const array = this.array;\r\n        const color = this.color;\r\n\r\n        // Calculate the weights for each pixel\r\n        const fx = x - px;\r\n        const fy = y - py;\r\n        const fx1 = 1 - fx;\r\n        const fy1 = 1 - fy;\r\n\r\n        const w1 = fx1 * fy1;\r\n        const w2 = fx * fy1;\r\n        const w3 = fx1 * fy;\r\n        const w4 = fx * fy;\r\n\r\n        let p1 = p0 * 4; \t\t\t\t\t\t\t// 0 + 0 * w\r\n        let p2 = ( 1 + p0 ) * 4; \t\t\t\t\t// 1 + 0 * w\r\n        let p3 = ( 1 * this.width + p0 ) * 4; \t\t// 0 + 1 * w\r\n        let p4 = ( 1 + 1 * this.width + p0 ) * 4; \t// 1 + 1 * w\r\n\r\n        const len = this.width * this.height * 4;\r\n\r\n        if (p1 >= len) p1 -= len;\r\n        if (p1 < 0) p1 += len;\r\n        if (p2 >= len) p2 -= len;\r\n        if (p2 < 0) p2 += len;\r\n        if (p3 >= len) p3 -= len;\r\n        if (p3 < 0) p3 += len;\r\n        if (p4 >= len) p4 -= len;\r\n        if (p4 < 0) p4 += len;\r\n\r\n        // Calculate the weighted sum of pixels (for each color channel)\r\n        color[0] = array[p1] * w1 + array[p2] * w2 + array[p3] * w3 + array[p4] * w4;\r\n        color[1] = array[p1 + 1] * w1 + array[p2 + 1] * w2 + array[p3 + 1] * w3 + array[p4 + 1] * w4;\r\n        color[2] = array[p1 + 2] * w1 + array[p2 + 2] * w2 + array[p3 + 2] * w3 + array[p4 + 2] * w4;\r\n        color[3] = array[p1 + 3] * w1 + array[p2 + 3] * w2 + array[p3 + 3] * w3 + array[p4 + 3] * w4;\r\n\r\n        return this.color;\r\n    }\r\n\r\n    getPixelOffset(offset) {\r\n        const array = this.array;\r\n        const color = this.color;\r\n\r\n        offset = parseInt(offset * 4);\r\n\r\n        color[0] = array[offset];\r\n        color[1] = array[offset + 1];\r\n        color[2] = array[offset + 2];\r\n        color[3] = array[offset + 3];\r\n\r\n        return this.color;\r\n    }\r\n}\r\n","import {Buffer} from './Buffer';\r\nimport {set} from '../operations/basic';\r\n\r\nexport class Texture {\r\n    constructor(width, height) {\r\n        this.color = new Float32Array(4);\r\n        this.buffer = new Buffer(width, height);\r\n        this.bufferCopy = new Buffer(width, height);\r\n    }\r\n\r\n    toImageData(context) {\r\n        const buffer = this.buffer;\r\n        const array = buffer.array;\r\n\r\n        const imageData = context.createImageData(buffer.width, buffer.height);\r\n        const data = imageData.data;\r\n\r\n        let i;\r\n        const il = array.length;\r\n\r\n        for (i = 0; i < il; i += 4) {\r\n            data[i] = array[i] * 255;\r\n            data[i + 1] = array[i + 1] * 255;\r\n            data[i + 2] = array[i + 2] * 255;\r\n            data[i + 3] = 255;\r\n        }\r\n\r\n        return imageData;\r\n    }\r\n\r\n    toCanvas(canvas) {\r\n        if (canvas === undefined) {\r\n            canvas = document.createElement('canvas');\r\n        }\r\n\r\n        canvas.width = this.buffer.width;\r\n        canvas.height = this.buffer.height;\r\n\r\n        const context = canvas.getContext('2d');\r\n        const imageData = this.toImageData(context);\r\n\r\n        context.putImageData(imageData, 0, 0);\r\n\r\n        return canvas;\r\n    }\r\n\r\n    set(program, operation) {\r\n        this.bufferCopy.copy(this.buffer);\r\n\r\n        const op = operation === undefined ? set : operation;\r\n        const dst = this.buffer;\r\n        const src = this.bufferCopy;\r\n        const color = this.color;\r\n        const tint = program.tint();\r\n\r\n        const array = dst.array;\r\n        const width = dst.width;\r\n        const height = dst.height;\r\n        const il = array.length;\r\n\r\n        let a = 1 - tint[3];\r\n        let b = tint[3];\r\n        let x = 0;\r\n        let y = 0;\r\n        let i;\r\n\r\n        if (tint[3] === 1) {\r\n            for (i = 0; i < il;) {\r\n                program.run(color, x, y, src, width, height);\r\n                array[i] = op(array[i++], color[0] * tint[0]);\r\n                array[i] = op(array[i++], color[1] * tint[1]);\r\n                array[i] = op(array[i++], color[2] * tint[2]);\r\n                i++;\r\n\r\n                if (++x === width) {\r\n                    x = 0;\r\n                    y++;\r\n                }\r\n            }\r\n        } else if (tint[3] !== 0) {\r\n            for (i = 0; i < il;) {\r\n                program.run(color, x, y, src, width, height);\r\n                array[i] = array[i] * a + op(array[i++], color[0] * tint[0]) * b;\r\n                array[i] = array[i] * a + op(array[i++], color[1] * tint[1]) * b;\r\n                array[i] = array[i] * a + op(array[i++], color[2] * tint[2]) * b;\r\n                i++;\r\n\r\n                if (++x === width) {\r\n                    x = 0;\r\n                    y++;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return this;\r\n    }\r\n\r\n    toArrayBuffer() {\r\n        const array = this.buffer.array;\r\n        const il = array.length;\r\n        const buffer = new ArrayBuffer(il);\r\n        const res = new Uint8ClampedArray(buffer);\r\n        let i;\r\n\r\n        for (i = 0; i < il; i += 4) {\r\n            res[i] = array[i] * 255;\r\n            res[i + 1] = array[i + 1] * 255;\r\n            res[i + 2] = array[i + 2] * 255;\r\n            res[i + 3] = 255;\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    static isSingleColor(buffer) {\r\n        const a = new Uint8ClampedArray(buffer);\r\n        const l = a.length;\r\n        let i = 4;\r\n\r\n        while (i < l) {\r\n            if (a[0] !== a[i++] || a[1] !== a[i++] || a[2] !== a[i++]) {\r\n                return false;\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nimport * as operations from '../operations/index';\r\n\r\nfor (let o in operations) {\r\n    if (!Texture.prototype[o]) {\r\n        Texture.prototype[o] = function (program) {\r\n            return this.set(program, operations[o]);\r\n        };\r\n    }\r\n}\r\n","export class Program {\r\n    constructor(proto) {\r\n        // this._tint = new Float32Array([1, 1, 1, 1]);\r\n        this._tint = {\r\n            0: 1, 1: 1, 2: 1, 3: 1, set: function (a) {\r\n                this._tint[0] = a[0];\r\n                this._tint[1] = a[1];\r\n                this._tint[2] = a[2];\r\n                this._tint[3] = a[3];\r\n            }\r\n        };\r\n\r\n        if (proto && proto.params) {\r\n            Object.keys(proto.params).forEach((p) => {\r\n                const v = proto.params[p].val;\r\n\r\n                if (v !== null) {\r\n                    if (Array.isArray(v)) {\r\n                        this[p].apply(this, v);\r\n                    } else {\r\n                        this[p].call(this, v);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    tint(r, g, b, a) {\r\n        if (arguments.length) {\r\n            this._tint[0] = r;\r\n            this._tint[1] = g;\r\n            this._tint[2] = b;\r\n            this._tint[3] = arguments.length > 3 ? a : this._tint[3];\r\n            return this;\r\n        } else {\r\n            return this._tint;\r\n        }\r\n    }\r\n}\r\n\r\nexport const Type = {\r\n    NUMBER: 0,\r\n    INT: 1,\r\n    BOOLEAN: 2,\r\n    INTERPOLATION: 3,\r\n    COLOR_POINT: 4,\r\n    COLOR: 5,\r\n    TEXTURE: 6,\r\n    0: 'NUMBER',\r\n    1: 'INT',\r\n    2: 'BOOLEAN',\r\n    3: 'INTERPOLATION',\r\n    4: 'COLOR_POINT',\r\n    5: 'COLOR',\r\n    6: 'TEXTURE'\r\n};\r\n\r\nexport const EPSILON = Number.EPSILON;\r\n","import {mixColors} from './mixColors';\r\nimport {mirroredWrap, wrap} from './wrap';\r\nimport {clamp} from './clamp';\r\n\r\nexport const ColorInterpolatorMethod = {\r\n    STEP: 0,\r\n    LINEAR: 1,\r\n    SPLINE: 2\r\n};\r\n\r\nexport class ColorInterpolator {\r\n    constructor(method) {\r\n        this.points = [];\r\n        this.low = 0;\r\n        this.high = 0;\r\n        this.interpolation = ( typeof( method ) === 'undefined' ) ? ColorInterpolatorMethod.LINEAR : method;\r\n        this.repeat = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    set(points) {\r\n        this.points = points;\r\n        this.points.sort(function (a, b) {\r\n            return a.pos - b.pos;\r\n        });\r\n\r\n        this.low = this.points[0].pos;\r\n        this.high = this.points[this.points.length - 1].pos;\r\n\r\n        return this;\r\n    }\r\n\r\n    addPoint(position, color) {\r\n\r\n        this.points.push({pos: position, color: color});\r\n        this.points.sort(function (a, b) {\r\n            return a.pos - b.pos;\r\n        });\r\n\r\n        this.low = this.points[0].pos;\r\n        this.high = this.points[this.points.length - 1].pos;\r\n\r\n        return this;\r\n    }\r\n\r\n    setRepeat(value) {\r\n        this.repeat = value;\r\n        return this;\r\n    }\r\n\r\n    setInterpolation(value) {\r\n        this.interpolation = value;\r\n        return this;\r\n    }\r\n\r\n    getColorAt(pos) {\r\n        if (!this.points.length) {\r\n            return [0, 0, 0];\r\n        } else if (this.repeat === 2) {\r\n            pos = mirroredWrap(pos, this.low, this.high);\r\n        }\r\n        else if (this.repeat) {\r\n            pos = wrap(pos, this.low, this.high);\r\n        }\r\n        else {\r\n            pos = clamp(pos, this.low, this.high);\r\n        }\r\n\r\n        let i = 0;\r\n        const points = this.points;\r\n\r\n        while (points[i + 1].pos < pos) i++;\r\n\r\n        const p1 = points[i];\r\n        const p2 = points[i + 1];\r\n\r\n        const delta = ( pos - p1.pos ) / ( p2.pos - p1.pos );\r\n\r\n        if (this.interpolation === ColorInterpolatorMethod.STEP) {\r\n            return p1.color;\r\n        } else if (this.interpolation === ColorInterpolatorMethod.LINEAR) {\r\n            return mixColors(p1.color, p2.color, delta);\r\n        } else if (this.interpolation === ColorInterpolatorMethod.SPLINE) {\r\n            const ar = 2 * p1.color[0] - 2 * p2.color[0];\r\n            const br = -3 * p1.color[0] + 3 * p2.color[0];\r\n            const dr = p1.color[0];\r\n\r\n            const ag = 2 * p1.color[1] - 2 * p2.color[1];\r\n            const bg = -3 * p1.color[1] + 3 * p2.color[1];\r\n            const dg = p1.color[1];\r\n\r\n            const ab = 2 * p1.color[2] - 2 * p2.color[2];\r\n            const bb = -3 * p1.color[2] + 3 * p2.color[2];\r\n            const db = p1.color[2];\r\n\r\n            const delta2 = delta * delta;\r\n            const delta3 = delta2 * delta;\r\n\r\n            return [\r\n                ar * delta3 + br * delta2 + dr,\r\n                ag * delta3 + bg * delta2 + dg,\r\n                ab * delta3 + bb * delta2 + db\r\n            ];\r\n        }\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Number extends Program {\r\n    run(color) {\r\n        color[0] = 1;\r\n        color[1] = 1;\r\n        color[2] = 1;\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class SinX extends Program {\r\n    constructor() {\r\n        super(SinX);\r\n    }\r\n\r\n    size(value) {\r\n        this._size = Math.max(Number.EPSILON, value) / Math.PI / 2;\r\n        return this;\r\n    }\r\n\r\n    offset(value) {\r\n        this._offset = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x) {\r\n        const value = Math.sin(( x + this._offset ) / this._size);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 16,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: 64,\r\n                offset: 16\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class SinY extends Program {\r\n    constructor() {\r\n        super(SinY);\r\n    }\r\n\r\n    size(value) {\r\n        this._size = Math.max(Number.EPSILON, value) / Math.PI / 2;\r\n        return this;\r\n    }\r\n\r\n    offset(value) {\r\n        this._offset = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = Math.sin(( y + this._offset ) / this._size);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 16,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Or extends Program {\r\n    constructor() {\r\n        super(Program);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [Math.max(Number.EPSILON, x), Math.max(Number.EPSILON, y)];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( (256 * x / this._size[0]) | (256 * y / this._size[1]) ) % 256 / 255;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [256, 256],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [64, 64]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Xor extends Program {\r\n    constructor() {\r\n        super(Xor);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [Math.max(Number.EPSILON, x), Math.max(Number.EPSILON, y)];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( 256 * x / this._size[0] ^ 256 * y / this._size[1] ) % 256 / 255;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [256, 256],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [128, 64]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Rect extends Program {\r\n    constructor() {\r\n        super(Rect);\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( x >= this._offset[0] && x <= ( this._offset[0] + this._size[0] ) && y <= ( this._offset[1] + this._size[1] ) && y >= this._offset[1] ) ? 1 : 0;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            size: {\r\n                val: [128, 64],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                offset: [(256 - 128) / 2, (256 - 64) / 2],\r\n                size: [128, 64]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\nimport {distance} from '../../utils/distance';\r\nimport {smoothStep} from '../../utils/smoothStep';\r\n\r\nexport class Circle extends Program {\r\n    constructor() {\r\n        super(Circle);\r\n    }\r\n\r\n    weight(value) {\r\n        this._delta = value;\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    size(value) {\r\n        this._size = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const dist = distance(x, y, this._offset[0], this._offset[1]);\r\n        const value = 1 - smoothStep(this._size - this._delta, this._size, dist);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            size: {\r\n                val: 128,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            weight: {\r\n                val: 1,\r\n                min: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                offset: [128, 128],\r\n                size: 128,\r\n                weight: 32\r\n            },\r\n            {\r\n                offset: [128, 128],\r\n                size: 128,\r\n                weight: 128\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class CheckerBoard extends Program {\r\n    constructor() {\r\n        super(CheckerBoard);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [x, y];\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    shift(value) {\r\n        this._shift = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( ( ( y + this._offset[1] ) / this._size[1] ) & 1 ) ^ ( ( ( x + this._offset[0] + parseInt(y / this._size[1]) * this._shift ) / this._size[0] ) & 1 ) ? 0 : 1;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [32, 32],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            shift: {\r\n                val: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [16, 16],\r\n                offset: [8, 8],\r\n                shift: 0\r\n            },\r\n            {\r\n                size: [64, 16],\r\n                offset: [0, 0],\r\n                shift: 8\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\n\r\nexport class LinearGradient extends Program {\r\n    constructor() {\r\n        super(LinearGradient);\r\n    }\r\n\r\n    size(value) {\r\n        this._size = Math.max(LinearGradient.params.size.min, value);\r\n        return this;\r\n    }\r\n\r\n    repeat(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setRepeat(value);\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    point(position, color) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.addPoint(position, color);\r\n        return this;\r\n    }\r\n\r\n    run(color, x) {\r\n        color.set(this._gradient.getColorAt(x / this._size));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 256,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            repeat: {\r\n                val: true,\r\n                type: Type.BOOLEAN\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            },\r\n            point: {\r\n                val: null,\r\n                type: Type.COLOR_POINT\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                interpolation: ColorInterpolatorMethod.STEP\r\n            },\r\n            {\r\n                interpolation: ColorInterpolatorMethod.SPLINE,\r\n                size: 128\r\n            },\r\n            {\r\n                interpolation: ColorInterpolatorMethod.SPLINE,\r\n                repeat: false,\r\n                size: 32\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\nimport {distance} from '../../utils/distance';\r\n\r\nexport class RadialGradient extends Program {\r\n    constructor() {\r\n        super(RadialGradient);\r\n    }\r\n\r\n    repeat(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setRepeat(value);\r\n        return this;\r\n    }\r\n\r\n    size(value) {\r\n        this._size = value;\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    point(position, color) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.addPoint(position, color);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const dist = distance(x, y, this._offset[0], this._offset[1]);\r\n        color.set(this._gradient.getColorAt(dist / this._size));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 128,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            repeat: {\r\n                val: true,\r\n                type: Type.BOOLEAN\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            },\r\n            point: {\r\n                val: null,\r\n                type: Type.COLOR_POINT\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: 64,\r\n                offset: [128, 128],\r\n                repeat: false\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {hashRNG} from './noiseBase/hashRNG';\r\n\r\nexport class Noise extends Program {\r\n    constructor() {\r\n        super(Noise);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = hashRNG(this._seed, x, y);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\nimport {hashRNG} from './noiseBase/hashRNG';\r\n\r\nexport class NoiseFractal extends Program {\r\n    constructor() {\r\n        super(NoiseFractal);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._baseFrequency = 1 / value;\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._interpolator = this._interpolator || new ColorInterpolator();\r\n        this._interpolator.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        let value = 0;\r\n        let amp = this._amplitude;\r\n        let freq = this._baseFrequency;\r\n        let x1, y1, dx, dy;\r\n        let v1, v2, v3, v4;\r\n        let i1, i2;\r\n\r\n        for (let j = 1; j <= this._octaves; j++) {\r\n            x1 = Math.floor(x * freq);\r\n            y1 = Math.floor(y * freq);\r\n\r\n            if (this._interpolator.interpolation === ColorInterpolatorMethod.STEP) {\r\n                value += hashRNG(this._seed * j, x1, y1) * amp;\r\n            } else {\r\n                dx = ( x * freq ) - x1;\r\n                dy = ( y * freq ) - y1;\r\n\r\n                v1 = hashRNG(this._seed * j, x1, y1);\r\n                v2 = hashRNG(this._seed * j, x1 + 1, y1);\r\n                v3 = hashRNG(this._seed * j, x1, y1 + 1);\r\n                v4 = hashRNG(this._seed * j, x1 + 1, y1 + 1);\r\n\r\n                this._interpolator.set([\r\n                    {pos: 0, color: [v1]},\r\n                    {pos: 1, color: [v2]}\r\n                ]);\r\n\r\n                i1 = this._interpolator.getColorAt(dx);\r\n\r\n                this._interpolator.set([\r\n                    {pos: 0, color: [v3]},\r\n                    {pos: 1, color: [v4]}\r\n                ]);\r\n\r\n                i2 = this._interpolator.getColorAt(dx);\r\n\r\n                this._interpolator.set([\r\n                    {pos: 0, color: [i1[0]]},\r\n                    {pos: 1, color: [i2[0]]}\r\n                ]);\r\n\r\n                value += this._interpolator.getColorAt(dy)[0] * amp;\r\n            }\r\n\r\n            freq *= this._step;\r\n            amp *= this._persistence;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 16,\r\n                min: 0\r\n            },\r\n            amplitude: {\r\n                val: 0.5,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.75,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 3,\r\n                min: 1,\r\n                max: 8\r\n            },\r\n            step: {\r\n                min: 1,\r\n                val: 4,\r\n                max: 16\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                amplitude: 1,\r\n                persistence: 0,\r\n                octaves: 1,\r\n                step: 4,\r\n                interpolation: 2\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 8,\r\n                amplitude: 1,\r\n                persistence: 1,\r\n                octaves: 1,\r\n                step: 4,\r\n                interpolation: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                amplitude: 1,\r\n                persistence: 1,\r\n                octaves: 1,\r\n                step: 4,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                amplitude: 1,\r\n                persistence: 1,\r\n                octaves: 2,\r\n                step: 2,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                amplitude: 0.25,\r\n                persistence: 0.75,\r\n                octaves: 4,\r\n                step: 2,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                amplitude: 0.25,\r\n                persistence: 0.75,\r\n                octaves: 4,\r\n                step: 2,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 3,\r\n                step: 4,\r\n                interpolation: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 3,\r\n                step: 4,\r\n                interpolation: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class CellularNoise extends Program {\r\n    constructor() {\r\n        super(CellularNoise);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const p = cellNoiseBase(x, y, this._seed, this._density, this._weight);\r\n\r\n        let value = 1 - ( p.dist / this._density );\r\n\r\n        if (this._density < 0) {\r\n            value -= 1;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 32,\r\n                min: 0\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: 0\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 16\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 32\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class CellularFractal extends Program {\r\n    constructor() {\r\n        super(CellularFractal);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    scale(value) {\r\n        this._scale = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        let p;\r\n        let value = 0;\r\n        let amp = this._amplitude;\r\n        let dens = this._density;\r\n\r\n        for (let j = 1; j <= this._octaves; j++) {\r\n            p = cellNoiseBase(x * this._scale, y * this._scale, this._seed * j, dens, this._weight);\r\n\r\n            p.dist = 1 - ( p.dist / dens );\r\n            if (dens < 0) p.dist -= 1;\r\n\r\n            value += p.dist * amp;\r\n            dens /= this._step;\r\n            amp *= this._persistence;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 64,\r\n                min: 0\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            amplitude: {\r\n                val: 0.5,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 4,\r\n                min: 1,\r\n                max: 8\r\n            },\r\n            step: {\r\n                val: 2,\r\n                min: 1,\r\n                max: 16\r\n            },\r\n            scale: {\r\n                val: 1,\r\n                scale: false\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 4,\r\n                step: 2\r\n            }, {\r\n                seed: 1,\r\n                density: 32,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 2,\r\n                step: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class VoronoiNoise extends Program {\r\n    constructor() {\r\n        super(VoronoiNoise);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const p = cellNoiseBase(x, y, this._seed, this._density, this._weight);\r\n\r\n        color[0] = p.value;\r\n        color[1] = p.value;\r\n        color[2] = p.value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 32,\r\n                min: EPSILON\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: 0\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 16\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 128\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class VoronoiFractal extends Program {\r\n    constructor() {\r\n        super(VoronoiFractal);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        let p;\r\n        let value = 0;\r\n        let amp = this._amplitude;\r\n        let dens = this._density;\r\n\r\n        for (let j = 1; j <= this._octaves; j++) {\r\n            p = cellNoiseBase(x, y, this._seed * j, dens, this._weight);\r\n\r\n            value += p.value * amp;\r\n            dens /= this._step;\r\n            amp *= this._persistence;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 64,\r\n                min: EPSILON\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: EPSILON,\r\n                max: 2\r\n            },\r\n            amplitude: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 4,\r\n                min: 1,\r\n                max: 8\r\n            },\r\n            step: {\r\n                val: 2,\r\n                min: 1,\r\n                max: 16\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 4,\r\n                step: 2\r\n            }, {\r\n                seed: 1,\r\n                density: 32,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 2,\r\n                step: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","/*\r\n * A speed-improved simplex noise algorithm for 2D, 3D and 4D in JavaScript.\r\n *\r\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\r\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\r\n * Better rank ordering method by Stefan Gustavson in 2012.\r\n *\r\n * This code was placed in the public domain by its original author,\r\n * Stefan Gustavson. You may use it as you see fit, but\r\n * attribution is appreciated.\r\n */\r\nexport default class FastSimplexNoise {\r\n    constructor(options = {}) {\r\n        if (options.hasOwnProperty('amplitude')) {\r\n            this.amplitude = options.amplitude;\r\n        }\r\n        else\r\n            this.amplitude = 1.0;\r\n        if (options.hasOwnProperty('frequency')) {\r\n            this.frequency = options.frequency;\r\n        }\r\n        else\r\n            this.frequency = 1.0;\r\n        if (options.hasOwnProperty('octaves')) {\r\n            this.octaves = options.octaves;\r\n        }\r\n        else\r\n            this.octaves = 1;\r\n        if (options.hasOwnProperty('persistence')) {\r\n            this.persistence = options.persistence;\r\n        }\r\n        else\r\n            this.persistence = 0.5;\r\n        if (options.hasOwnProperty('random')) {\r\n            this.random = options.random;\r\n        }\r\n        else\r\n            this.random = Math.random;\r\n        let min;\r\n        if (options.hasOwnProperty('min')) {\r\n            min = options.min;\r\n        }\r\n        else\r\n            min = -1;\r\n        let max;\r\n        if (options.hasOwnProperty('max')) {\r\n            max = options.max;\r\n        }\r\n        else\r\n            max = 1;\r\n        this.scale = min === -1 && max === 1\r\n            ? value => value\r\n            : value => min + ((value + 1) / 2) * (max - min);\r\n        const p = new Uint8Array(256);\r\n        for (let i = 0; i < 256; i++)\r\n            p[i] = i;\r\n        let n;\r\n        let q;\r\n        for (let i = 255; i > 0; i--) {\r\n            n = Math.floor((i + 1) * this.random());\r\n            q = p[i];\r\n            p[i] = p[n];\r\n            p[n] = q;\r\n        }\r\n        this.perm = new Uint8Array(512);\r\n        this.permMod12 = new Uint8Array(512);\r\n        for (let i = 0; i < 512; i++) {\r\n            this.perm[i] = p[i & 255];\r\n            this.permMod12[i] = this.perm[i] % 12;\r\n        }\r\n    }\r\n\r\n    dot(gs, coords) {\r\n        return gs\r\n            .slice(0, Math.min(gs.length, coords.length))\r\n            .reduce((total, g, i) => total + (g * coords[i]), 0);\r\n    }\r\n\r\n    raw2D(x, y) {\r\n        // Skew the input space to determine which simplex cell we're in\r\n        const s = (x + y) * 0.5 * (Math.sqrt(3.0) - 1.0); // Hairy factor for 2D\r\n        const i = Math.floor(x + s);\r\n        const j = Math.floor(y + s);\r\n        const t = (i + j) * FastSimplexNoise.G2;\r\n        const X0 = i - t; // Unskew the cell origin back to (x,y) space\r\n        const Y0 = j - t;\r\n        const x0 = x - X0; // The x,y distances from the cell origin\r\n        const y0 = y - Y0;\r\n        // Determine which simplex we are in.\r\n        const i1 = x0 > y0 ? 1 : 0;\r\n        const j1 = x0 > y0 ? 0 : 1;\r\n        // Offsets for corners\r\n        const x1 = x0 - i1 + FastSimplexNoise.G2;\r\n        const y1 = y0 - j1 + FastSimplexNoise.G2;\r\n        const x2 = x0 - 1.0 + 2.0 * FastSimplexNoise.G2;\r\n        const y2 = y0 - 1.0 + 2.0 * FastSimplexNoise.G2;\r\n        // Work out the hashed gradient indices of the three simplex corners\r\n        const ii = i & 255;\r\n        const jj = j & 255;\r\n        const gi0 = this.permMod12[ii + this.perm[jj]];\r\n        const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];\r\n        const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];\r\n        // Calculate the contribution from the three corners\r\n        const t0 = 0.5 - x0 * x0 - y0 * y0;\r\n        const n0 = t0 < 0 ? 0.0 : Math.pow(t0, 4) * this.dot(FastSimplexNoise.GRAD3D[gi0], [x0, y0]);\r\n        const t1 = 0.5 - x1 * x1 - y1 * y1;\r\n        const n1 = t1 < 0 ? 0.0 : Math.pow(t1, 4) * this.dot(FastSimplexNoise.GRAD3D[gi1], [x1, y1]);\r\n        const t2 = 0.5 - x2 * x2 - y2 * y2;\r\n        const n2 = t2 < 0 ? 0.0 : Math.pow(t2, 4) * this.dot(FastSimplexNoise.GRAD3D[gi2], [x2, y2]);\r\n        // Add contributions from each corner to get the final noise value.\r\n        // The result is scaled to return values in the interval [-1, 1]\r\n        return 70.14805770653952 * (n0 + n1 + n2);\r\n    }\r\n\r\n    scaled2D(x, y) {\r\n        let amplitude = this.amplitude;\r\n        let frequency = this.frequency;\r\n        let maxAmplitude = 0;\r\n        let noise = 0;\r\n        for (let i = 0; i < this.octaves; i++) {\r\n            noise += this.raw2D(x * frequency, y * frequency) * amplitude;\r\n            maxAmplitude += amplitude;\r\n            amplitude *= this.persistence;\r\n            frequency *= 2;\r\n        }\r\n        return this.scale(noise / maxAmplitude);\r\n    }\r\n}\r\nFastSimplexNoise.G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\r\nFastSimplexNoise.GRAD3D = [\r\n    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],\r\n    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],\r\n    [0, 1, 1], [0, -1, -1], [0, 1, -1], [0, -1, -1]\r\n];\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport FastSimplexNoise from './simplexNoiseBase/FastSimplexNoise';\r\nimport {hashRNG} from './noiseBase/hashRNG';\r\n\r\nexport class SimplexNoise extends Program {\r\n    constructor() {\r\n        super(SimplexNoise);\r\n        this._count = 0;\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        this._base = this._base || new FastSimplexNoise({\r\n                min: 0,\r\n                max: 1,\r\n                frequency: 1 / this._density,\r\n                octaves: this._octaves,\r\n                amplitude: this._amplitude,\r\n                persistence: this._persistence,\r\n                random: function () {\r\n                    return hashRNG(this._seed, this._count++, 0);\r\n                }\r\n            });\r\n\r\n        const value = this._base.scaled2D(x, y);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 16,\r\n                min: EPSILON\r\n            },\r\n            amplitude: {\r\n                val: 1,\r\n                min: EPSILON,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 1,\r\n                min: 1,\r\n                max: 8\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 128,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 8\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 128,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 5\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 12,\r\n                amplitude: 0.25,\r\n                persistence: 1,\r\n                octaves: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Abs extends Program {\r\n    run(color, x, y, src) {\r\n        const value = src.getPixelNearest(x, y);\r\n        color[0] = Math.abs(value[0]);\r\n        color[1] = Math.abs(value[1]);\r\n        color[2] = Math.abs(value[2]);\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Copy extends Program {\r\n    run(color, x, y, src) {\r\n        const value = src.getPixelNearest(x, y);\r\n        color.set(value);\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {clamp} from \"../../utils/clamp\";\r\n\r\nexport class Convolution extends Program {\r\n    constructor() {\r\n        super(Convolution);\r\n    }\r\n\r\n    preset(value) {\r\n        this._weights = Convolution.Presets[value] || Convolution.Presets[0];\r\n        this._side = Math.round(Math.sqrt(this._weights.length));\r\n        this._halfSide = Math.floor(this._side / 2);\r\n        return this;\r\n    }\r\n\r\n    static get Presets() {\r\n        return {\r\n            0: [0, -1, 0,\r\n                -1, 5, -1,\r\n                0, -1, 0],\r\n            1: [1 / 9, 1 / 9, 1 / 9,\r\n                1 / 9, 1 / 9, 1 / 9,\r\n                1 / 9, 1 / 9, 1 / 9],\r\n            2: [1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25],\r\n            3: [2, 1, 0,\r\n                1, 1, -1,\r\n                0, -1, -2],\r\n            4: [0, 1, 0,\r\n                1, -4, 1,\r\n                0, 1, 0]\r\n        };\r\n    }\r\n\r\n    run(color, x, y, src, width, height) {\r\n        const sy = y;\r\n        const sx = x;\r\n        let r = 0, g = 0, b = 0;\r\n\r\n        for (let cy = 0; cy < this._side; cy++) {\r\n            for (let cx = 0; cx < this._side; cx++) {\r\n                const scy = sy + cy - this._halfSide;\r\n                const scx = sx + cx - this._halfSide;\r\n                const wt = this._weights[cy * this._side + cx];\r\n                const value = src.getPixelNearest(clamp(scx, 0, width - 1), clamp(scy, 0, height - 1));\r\n                r += value[0] * wt;\r\n                g += value[1] * wt;\r\n                b += value[2] * wt;\r\n            }\r\n        }\r\n\r\n        color[0] = r;\r\n        color[1] = g;\r\n        color[2] = b;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            preset: {\r\n                val: 0,\r\n                min: 0,\r\n                max: 4,\r\n                type: Type.INT\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                preset: 1\r\n            },\r\n            {\r\n                preset: 2\r\n            },\r\n            {\r\n                preset: 3\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport FastSimplexNoise from \"../generators/simplexNoiseBase/FastSimplexNoise\";\r\nimport {hashRNG} from \"../generators/noiseBase/hashRNG\";\r\n\r\nexport class Distort extends Program {\r\n    constructor() {\r\n        super(Distort);\r\n        this._count = 0;\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        this._base = this._base || new FastSimplexNoise({\r\n                min: -1,\r\n                max: 1,\r\n                frequency: 1 / this._density,\r\n                octaves: this._octaves,\r\n                amplitude: this._amplitude,\r\n                persistence: this._persistence,\r\n                random: function () {\r\n                    return hashRNG(this._seed, this._count++, 0);\r\n                }\r\n            });\r\n\r\n        const value = this._base.scaled2D(x, y);\r\n        const s = x + this._weight * value;\r\n        const t = y + this._weight * value;\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 32,\r\n                min: EPSILON\r\n            },\r\n            amplitude: {\r\n                val: 1,\r\n                min: EPSILON,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 1,\r\n                min: 1,\r\n                type: Type.INT,\r\n                max: 8\r\n            },\r\n            weight: {\r\n                val: 4,\r\n                min: Number.EPSILON\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 128,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 1,\r\n                weight: 32\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 1,\r\n                weight: 32\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\n\r\nexport class GradientMap extends Program {\r\n    repeat(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setRepeat(value);\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    point(position, color) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.addPoint(position, color);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const v = src.getPixelNearest(x, y);\r\n\r\n        const r = this._gradient.getColorAt(v[0])[0];\r\n        const g = this._gradient.getColorAt(v[1])[1];\r\n        const b = this._gradient.getColorAt(v[2])[2];\r\n\r\n        color[0] = r;\r\n        color[1] = g;\r\n        color[2] = b;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            repeat: {\r\n                val: true,\r\n                type: Type.BOOLEAN\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            },\r\n            point: {\r\n                val: null,\r\n                type: Type.COLOR_POINT\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Grayscale extends Program {\r\n    run(color, x, y, src) {\r\n        const value = src.getPixelNearest(x, y);\r\n        const g = .2126 * value[0] + .7152 * value[1] + .0722 * value[2];\r\n        color[0] = g;\r\n        color[1] = g;\r\n        color[2] = g;\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Normalize extends Program {\r\n    multiplier(value) {\r\n        this._multiplier = value;\r\n        return this;\r\n    }\r\n\r\n    offset(value) {\r\n        this._offset = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        if (!this._init) {\r\n            let high = -Infinity;\r\n            let low = Infinity;\r\n\r\n            let j = 0;\r\n            const len = src.array.length;\r\n            for (; j < len; j++) {\r\n                if (j % 4 === 3) continue;\r\n\r\n                high = ( src.array[j] > high ) ? src.array[j] : high;\r\n                low = ( src.array[j] < low  ) ? src.array[j] : low;\r\n            }\r\n\r\n            this._offset = -low;\r\n            this._multiplier = 1 / ( high - low );\r\n            this._init = true;\r\n        }\r\n\r\n        const v = src.getPixelNearest(x, y);\r\n        color[0] = ( v[0] + this._offset ) * this._multiplier;\r\n        color[1] = ( v[1] + this._offset ) * this._multiplier;\r\n        color[2] = ( v[2] + this._offset ) * this._multiplier;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            multiplier: {\r\n                val: 1\r\n            },\r\n            offset: {\r\n                val: 0\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\n\r\nexport class Pixelate extends Program {\r\n    constructor() {\r\n        super(Pixelate);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const s = this._size[0] * Math.floor(x / this._size[0]);\r\n        const t = this._size[1] * Math.floor(y / this._size[1]);\r\n\r\n        color.set(src.getPixelNearest(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [2, 2],\r\n                type: Type.INT,\r\n                min: 2,\r\n                max: 256\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Posterize extends Program {\r\n    constructor() {\r\n        super(Posterize);\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(value, 2);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const v = src.getPixelNearest(x, y);\r\n        color[0] = Math.floor(Math.floor(v[0] * 255 / ( 255 / this._step )) * 255 / ( this._step - 1 )) / 255;\r\n        color[1] = Math.floor(Math.floor(v[1] * 255 / ( 255 / this._step )) * 255 / ( this._step - 1 )) / 255;\r\n        color[2] = Math.floor(Math.floor(v[2] * 255 / ( 255 / this._step )) * 255 / ( this._step - 1 )) / 255;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            step: {\r\n                val: 2\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {EPSILON, Program} from '../../core/Program';\r\n\r\nexport class SineDistort extends Program {\r\n    constructor() {\r\n        super(SineDistort);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [Math.max(Number.EPSILON, x) / Math.PI / 2, Math.max(Number.EPSILON, y) / Math.PI / 2];\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    amplitude(x, y) {\r\n        this._amplitude = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const s = x + Math.sin(y / this._size[0] + this._offset[0]) * this._amplitude[0];\r\n        const t = y + Math.sin(x / this._size[1] + this._offset[1]) * this._amplitude[1];\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {val: [32, 32], min: EPSILON},\r\n            offset: {val: [0, 0]},\r\n            amplitude: {val: [8, 8], min: EPSILON}\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [128, 128],\r\n                offset: [0, 0],\r\n                amplitude: [64, 64],\r\n            },\r\n            {\r\n                size: [256, 256],\r\n                offset: [0, 0],\r\n                amplitude: [32, 32],\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\nimport {deg2rad} from '../../utils/deg2rad';\r\n\r\nexport class Transform extends Program {\r\n    constructor() {\r\n        super(Transform);\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    angle(value) {\r\n        this._angle = deg2rad(value);\r\n        return this;\r\n    }\r\n\r\n    scale(x, y) {\r\n        if (x === 0 || y === 0) return;\r\n        this._scale = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src, width, height) {\r\n        const x2 = x - width / 2;\r\n        const y2 = y - height / 2;\r\n\r\n        let s = x2 * ( Math.cos(this._angle) / this._scale[0] ) + y2 * -( Math.sin(this._angle) / this._scale[0] );\r\n        let t = x2 * ( Math.sin(this._angle) / this._scale[1] ) + y2 * ( Math.cos(this._angle) / this._scale[1] );\r\n\r\n        s += this._offset[0] + width / 2;\r\n        t += this._offset[1] + height / 2;\r\n\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {val: [0, 0]},\r\n            angle: {val: 0, min: 0, max: 360},\r\n            scale: {val: [1, 1]}\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                offset: [0, 0],\r\n                angle: 45,\r\n                scale: [2, 2]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\nimport {distance} from '../../utils/distance';\r\n\r\nexport class Twirl extends Program {\r\n    constructor() {\r\n        super(Twirl);\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = value;\r\n        return this;\r\n    }\r\n\r\n    size(value) {\r\n        this._size = value;\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        let dist = distance(x, y, this._offset[0], this._offset[1]);\r\n        let s, t;\r\n\r\n        // no distortion if outside of whirl size.\r\n        if (dist < this._size) {\r\n            dist = Math.pow(this._size - dist, 2) / this._size;\r\n\r\n            const angle = 2.0 * Math.PI * (dist / (this._size / this._weight));\r\n            s = (((x - this._offset[0]) * Math.cos(angle)) - ((y - this._offset[0]) * Math.sin(angle)) + this._offset[0] + 0.5);\r\n            t = (((y - this._offset[1]) * Math.cos(angle)) + ((x - this._offset[1]) * Math.sin(angle)) + this._offset[1] + 0.5);\r\n        } else {\r\n            s = x;\r\n            t = y;\r\n        }\r\n\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            weight: {\r\n                val: 0.5,\r\n                min: -1,\r\n                max: 1\r\n            },\r\n            size: {\r\n                val: 128\r\n            },\r\n            offset: {\r\n                val: [128, 128]\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {mirroredWrap, wrap} from '../../utils/wrap';\r\nimport {clamp} from '../../utils/clamp';\r\n\r\nexport class PutTexture extends Program {\r\n    constructor() {\r\n        super(PutTexture);\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    repeat(value) {\r\n        this._repeat = value;\r\n        return this;\r\n    }\r\n\r\n    texture(value) {\r\n        this._srcTex = value.buffer;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        this._srcTex = this._srcTex || src;\r\n        const texWidth = this._srcTex.width;\r\n        const texHeight = this._srcTex.height;\r\n\r\n        const texX = Math.floor(x - this._offset[0]);\r\n        const texY = Math.floor(y - this._offset[1]);\r\n\r\n        if (texX >= texWidth || texY >= texHeight || texX < 0 || texY < 0) {\r\n            if (this._repeat) {\r\n                let nx, ny;\r\n                const rangeX = texWidth - 1;\r\n                const rangeY = texHeight - 1;\r\n\r\n                if (this._repeat === 1) {\r\n                    nx = wrap(texX, 0, texWidth);\r\n                    ny = wrap(texY, 0, texHeight);\r\n                } else if (this._repeat === 2) {\r\n                    nx = mirroredWrap(texX, 0, rangeX);\r\n                    ny = mirroredWrap(texY, 0, rangeY);\r\n                } else if (this._repeat === 3) {\r\n                    nx = clamp(texX, 0, rangeX);\r\n                    ny = clamp(texY, 0, rangeY);\r\n                }\r\n\r\n                color.set(this._srcTex.getPixelNearest(nx, ny));\r\n            } else {\r\n                color[0] = 0;\r\n                color[1] = 0;\r\n                color[2] = 0;\r\n            }\r\n        } else {\r\n            color.set(this._srcTex.getPixelNearest(texX, texY));\r\n        }\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {\r\n                val: [0, 0]\r\n            },\r\n            repeat: {\r\n                val: false,\r\n                type: Type.BOOLEAN\r\n            },\r\n            texture: {\r\n                val: null,\r\n                type: Type.TEXTURE\r\n            }\r\n        };\r\n    }\r\n}\r\n","import * as Generators from './generators/index';\r\nimport * as Filters from './filters/index';\r\nimport * as Mixers from './mixers/index';\r\n\r\nexport const Programs = {\r\n    Generators: Generators,\r\n    Filters: Filters,\r\n    Mixers: Mixers\r\n};\r\n","export {Texture} from './core/Texture';\r\nexport {Buffer} from './core/Buffer';\r\nexport {Program, Type, EPSILON} from './core/Program';\r\n\r\nexport {ColorInterpolatorMethod} from './utils/ColorInterpolator';\r\n\r\nexport * from './programs/generators/index';\r\nexport * from './programs/filters/index';\r\nexport * from './programs/mixers/index';\r\n\r\nimport * as operations from './operations/index';\r\nexport const Operations = operations;\r\nexport {Programs} from './programs/index';\r\n\r\nexport {bufferToCanvas} from './utils/bufferToCanvas';\r\n\r\nexport const version = '2.0.0';\r\n","export default function(min, max) {\n  min = min == null ? 0 : +min;\n  max = max == null ? 1 : +max;\n  if (arguments.length === 1) max = min, min = 0;\n  else max -= min;\n  return function() {\n    return Math.random() * max + min;\n  };\n}\n","export const colors = [\r\n    [0, .5, 1],\r\n    [0, 1, .5],\r\n    [0, 1, 1],\r\n    [.5, 0, 1],\r\n    [.5, 1, 0],\r\n    [1, 0, .5],\r\n    [1, 0, 1],\r\n    [1, .5, 0],\r\n    [1, 1, 0]\r\n];\r\n","export const WIDTH = 'w';\r\nexport const HEIGHT = 'h';\r\n","import _samples from './samples.json';\r\n\r\nexport const samples = _samples;\r\n"],"names":["set","x","y","add","sub","mul","div","and","xor","min","Math","max","average","a","b","screen","overlay","linearBurn","colorBurn","colorDodge","difference","abs","exclusion","softLight","hardLight","vividLight","linearLight","pinLight","mixColors","c1","c2","delta","wrap","value","v","r","mirroredWrap","clamp","distance","x0","y0","x1","y1","dx","dy","sqrt","smoothStep","edge0","edge1","xx","hashRNG","seed","s","cellNoiseBase","density","weight","qx","qy","rx","ry","w","px","py","dist","shortest","Infinity","sx","sy","ceil","deg2rad","deg","dr","bufferToCanvas","buffer","width","height","canvas","can","document","createElement","ctx","getContext","imageData","getImageData","data","heap","Uint8Array","last","length","i","putImageData","getSchema","schema","definitions","operation","enum","Object","keys","TG","texture","items","properties","program","anyOf","Generators","Filters","Mixers","addPrograms","n","l","forEach","k","push","o","params","p","q","t","pt","Array","isArray","val","type","isNaN","minItems","maxItems","Type","BOOLEAN","COLOR_POINT","$ref","INTERPOLATION","NUMBER","minimum","maximum","INT","default","getRef","parts","slice","split","part","traverse","current","root","c","result","Error","floor","randomUniform","parseFloat","Number","MIN_VALUE","MAX_VALUE","toPrecision","item","picked","prop","getRandom","Programs","render","getProgram","tt","pr","filter","undefined","getFeatures","ret","baseId","tint","mixId","addGenerators","defs","color","colors","examples","e","addFilters","base","map","addMixers","mix","addOperations","addAlphas","recipeToBody","formula","proportional","block","WIDTH","HEIGHT","CR","SP","def","$hide","g","join","getValue","param","scale","scaled","bodyToFunction","body","Function","recipeToFunction","formatRecipe","precision","removeHide","d","formatNumber","m","componentOnIndex","index","f","componentToIndex","j","getWorkers","path","worker","free","workers","queue","postMessage","msg","onmessage","toBePosted","waiting","shift","Worker","terminate","Buffer","array","Float32Array","_x","round","_y","this","offset","p0","fx","fy","fx1","fy1","w1","w2","w3","w4","p1","p2","p3","p4","len","parseInt","Texture","bufferCopy","context","createImageData","il","toImageData","copy","op","dst","src","run","ArrayBuffer","res","Uint8ClampedArray","prototype","operations","Program","proto","_tint","1","2","3","apply","call","arguments","EPSILON","ColorInterpolatorMethod","ColorInterpolator","method","points","low","high","interpolation","LINEAR","repeat","sort","pos","position","STEP","SPLINE","ar","br","ag","bg","dg","ab","bb","db","delta2","delta3","SinX","_size","PI","_offset","sin","SinY","Or","Xor","Rect","Circle","_delta","CheckerBoard","_shift","LinearGradient","size","_gradient","setRepeat","setInterpolation","addPoint","getColorAt","RadialGradient","Noise","_seed","NoiseFractal","_baseFrequency","_amplitude","_persistence","_octaves","_step","_interpolator","amp","freq","v1","v2","v3","v4","i1","i2","CellularNoise","_density","_weight","CellularFractal","_scale","dens","VoronoiNoise","VoronoiFractal","FastSimplexNoise","options","hasOwnProperty","amplitude","frequency","octaves","persistence","random","perm","permMod12","gs","coords","reduce","total","G2","X0","Y0","j1","x2","y2","ii","jj","gi0","gi1","gi2","t0","n0","pow","dot","GRAD3D","t1","n1","t2","n2","maxAmplitude","noise","raw2D","SimplexNoise","_count","_base","scaled2D","Abs","getPixelNearest","Copy","Convolution","_weights","Presets","_side","_halfSide","cy","cx","scy","scx","wt","Distort","getPixelBilinear","GradientMap","Grayscale","Normalize","_multiplier","_init","Pixelate","Posterize","SineDistort","Transform","_angle","cos","Twirl","angle","PutTexture","_repeat","_srcTex","texWidth","texHeight","texX","texY","nx","ny","rangeX","rangeY","TEXTURE","Operations","version","samples","_samples"],"mappings":"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"}