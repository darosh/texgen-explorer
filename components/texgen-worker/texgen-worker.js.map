{"version":3,"file":"texgen-worker.js","sources":["../texgen/operations/basic.js","../texgen/operations/advanced.js","../texgen/utils/mixColors.js","../texgen/utils/wrap.js","../texgen/utils/clamp.js","../texgen/utils/distance.js","../texgen/utils/smoothStep.js","../texgen/programs/generators/noiseBase/hashRNG.js","../texgen/programs/generators/celularNoiseBase/cellNoiseBase.js","../texgen/utils/deg2rad.js","../texgen/utils/bufferToCanvas.js","../texgen-recipe/bodyToFunction.js","../texgen/core/Buffer.js","../texgen/core/Texture.js","../texgen/core/Program.js","../texgen/utils/ColorInterpolator.js","../texgen/programs/generators/Number.js","../texgen/programs/generators/SinX.js","../texgen/programs/generators/SinY.js","../texgen/programs/generators/Or.js","../texgen/programs/generators/Xor.js","../texgen/programs/generators/Rect.js","../texgen/programs/generators/Circle.js","../texgen/programs/generators/CheckerBoard.js","../texgen/programs/generators/LinearGradient.js","../texgen/programs/generators/RadialGradient.js","../texgen/programs/generators/Noise.js","../texgen/programs/generators/NoiseFractal.js","../texgen/programs/generators/CellularNoise.js","../texgen/programs/generators/CellularFractal.js","../texgen/programs/generators/VoronoiNoise.js","../texgen/programs/generators/VoronoiFractal.js","../texgen/programs/generators/simplexNoiseBase/FastSimplexNoise.js","../texgen/programs/generators/SimplexNoise.js","../texgen/programs/filters/Abs.js","../texgen/programs/filters/Copy.js","../texgen/programs/filters/Convolution.js","../texgen/programs/filters/Distort.js","../texgen/programs/filters/GradientMap.js","../texgen/programs/filters/Grayscale.js","../texgen/programs/filters/Normalize.js","../texgen/programs/filters/Pixelate.js","../texgen/programs/filters/Posterize.js","../texgen/programs/filters/SineDistort.js","../texgen/programs/filters/Transform.js","../texgen/programs/filters/Twirl.js","../texgen/programs/mixers/PutTexture.js","../texgen/programs/index.js","../texgen/index.js","../texgen-recipe/params.js","index.js"],"sourcesContent":["export function set(x, y) {\r\n    return y;\r\n}\r\n\r\nexport function add(x, y) {\r\n    return x + y;\r\n}\r\n\r\nexport function sub(x, y) {\r\n    return x - y;\r\n}\r\n\r\nexport function mul(x, y) {\r\n    return x * y;\r\n}\r\n\r\nexport function div(x, y) {\r\n    return x / y;\r\n}\r\n\r\nexport function and(x, y) {\r\n    return x & y;\r\n}\r\n\r\nexport function xor(x, y) {\r\n    return x ^ y;\r\n}\r\n\r\nexport function min(x, y) {\r\n    return Math.min(x, y);\r\n}\r\n\r\nexport function max(x, y) {\r\n    return Math.max(x, y);\r\n}\r\n","export function average(a, b) {\r\n    return (a + b) / 2;\r\n}\r\n\r\nexport function screen(a, b) {\r\n    return 1 - (1 - a) * (1 - b);\r\n}\r\n\r\nexport function overlay(a, b) {\r\n    return (b < .5)\r\n        ? (2 * a * b)\r\n        : (1 - 2 * (1 - a) * (1 - b));\r\n}\r\n\r\nexport function linearBurn(a, b) {\r\n    return a + b - 1;\r\n}\r\n\r\nexport function colorBurn(a, b) {\r\n    return (b === 0) ? b : (1 - (1 - a) / b);\r\n}\r\n\r\nexport function colorDodge(a, b) {\r\n    return (b >= 1) ? b : (a / (1 - b));\r\n}\r\n\r\nexport function difference(a, b) {\r\n    return Math.abs(a - b);\r\n}\r\n\r\nexport function exclusion(a, b) {\r\n    return .5 - 2 * (a - .5) * (b - .5);\r\n}\r\n\r\nexport function softLight(a, b) {\r\n    return (b < .5)\r\n        ? (2 * ((a / 2) + .25)) * b\r\n        : (1 - (2 * (1 - ((a / 2) + .25)) * (1 - b)));\r\n}\r\nexport function hardLight(a, b) {\r\n    return (a < .5)\r\n        ? (2 * b * a)\r\n        : (1 - 2 * (1 - b) * (1 - a));\r\n}\r\n\r\nexport function vividLight(a, b) {\r\n    return (a > .5)\r\n        ? (1 - (1 - b) / (2 * (a - .5)))\r\n        : (b / (1 - 2 * a));\r\n}\r\nexport function linearLight(a, b) {\r\n    return (b > 0.5)\r\n        ? (a + 2 * (b - .5))\r\n        : (a + 2 * b - 1);\r\n}\r\n\r\nexport function pinLight(a, b) {\r\n    return (b > 0.5)\r\n        ? Math.max(a, 2 * (b - .5))\r\n        : Math.min(a, 2 * b);\r\n}\r\n","export function mixColors(c1, c2, delta) {\r\n    return [\r\n        c1[0] * ( 1 - delta ) + c2[0] * delta,\r\n        c1[1] * ( 1 - delta ) + c2[1] * delta,\r\n        c1[2] * ( 1 - delta ) + c2[2] * delta\r\n        // c1[3] * ( 1 - delta ) + c2[3] * delta\r\n    ];\r\n}\r\n","export function wrap(value, min, max) {\r\n    const v = value - min;\r\n    const r = max - min;\r\n\r\n    return ( ( r + v % r ) % r ) + min;\r\n}\r\n\r\nexport function mirroredWrap(value, min, max) {\r\n    let v = value - min;\r\n    const r = ( max - min ) * 2;\r\n\r\n    v = ( r + v % r ) % r;\r\n\r\n    if (v > max - min) {\r\n        return ( r - v ) + min;\r\n    } else {\r\n        return v + min;\r\n    }\r\n}\r\n","export function clamp(value, min, max) {\r\n    return Math.min(Math.max(value, min), max);\r\n}\r\n","export function distance(x0, y0, x1, y1) {\r\n    const dx = x1 - x0, dy = y1 - y0;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n","import {clamp} from './clamp';\r\n\r\nexport function smoothStep(edge0, edge1, x) {\r\n    // Scale, bias and saturate x to 0..1 range\r\n    let xx = clamp(( x - edge0 ) / ( edge1 - edge0 ), 0, 1);\r\n\r\n    // Evaluate polynomial\r\n    return xx * xx * ( 3 - 2 * xx );\r\n}\r\n","export function hashRNG(seed, x, y) {\r\n    const s = ( Math.abs(seed % 2147483648) === 0 ) ? 1 : seed;\r\n    let a = ( ( s * ( x + 1 ) * 777 ) ^ ( s * ( y + 1 ) * 123 ) ) % 2147483647;\r\n\r\n    a = (a ^ 61) ^ (a >> 16);\r\n    a = a + (a << 3);\r\n    a = a ^ (a >> 4);\r\n    a = a * 0x27d4eb2d;\r\n    a = a ^ (a >> 15);\r\n    a = a / 2147483647;\r\n\r\n    return a;\r\n}\r\n","import {hashRNG} from '../noiseBase/hashRNG';\r\n\r\nexport function cellNoiseBase(x, y, seed, density, weight) {\r\n    let qx, qy, rx, ry, w, px, py, dx, dy;\r\n    let dist, value;\r\n    let shortest = Infinity;\r\n    density = Math.abs(density);\r\n\r\n    for (let sx = -2; sx <= 2; sx++) {\r\n        for (let sy = -2; sy <= 2; sy++) {\r\n            qx = Math.ceil(x / density) + sx;\r\n            qy = Math.ceil(y / density) + sy;\r\n\r\n            rx = hashRNG(seed, qx, qy);\r\n            ry = hashRNG(seed * 2, qx, qy);\r\n            w = ( weight > 0 ) ? 1 + hashRNG(seed * 3, qx, qy) * weight : 1;\r\n\r\n            px = ( rx + qx ) * density;\r\n            py = ( ry + qy ) * density;\r\n\r\n            dx = Math.abs(px - x);\r\n            dy = Math.abs(py - y);\r\n\r\n            dist = ( dx * dx + dy * dy ) * w;\r\n\r\n            if (dist < shortest) {\r\n                shortest = dist;\r\n                value = rx;\r\n            }\r\n        }\r\n    }\r\n\r\n    return {dist: Math.sqrt(shortest), value: value};\r\n}\r\n","const dr = Math.PI / 180;\r\n\r\nexport function deg2rad(deg) {\r\n    return deg * dr;\r\n}\r\n","export function bufferToCanvas(buffer, width, height, canvas = null) {\r\n    const can = canvas || document.createElement('canvas');\r\n    can.width = width;\r\n    can.height = height;\r\n    const ctx = can.getContext('2d');\r\n    const imageData = ctx.getImageData(0, 0, width, height);\r\n    const data = imageData.data;\r\n    const heap = new Uint8Array(buffer);\r\n    const last = heap.length;\r\n    let i = 0;\r\n\r\n    while (i < last) {\r\n        data[i] = heap[i++];\r\n    }\r\n\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    return can;\r\n}\r\n","import {HEIGHT, WIDTH} from './params';\r\n\r\nexport function bodyToFunction(body) {\r\n    return new Function(WIDTH, HEIGHT, 'return ' + body);\r\n}\r\n","export class Buffer {\r\n    constructor(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.array = new Float32Array(width * height * 4);\r\n        this.color = new Float32Array(4);\r\n    }\r\n\r\n    copy(buffer) {\r\n        this.array.set(buffer.array);\r\n    }\r\n\r\n    getPixelNearest(x, y) {\r\n        let _x = Math.round(x);\r\n        let _y = Math.round(y);\r\n\r\n        while (_y >= this.height) _y -= this.height;\r\n        while (_y < 0) _y += this.height;\r\n        while (_x >= this.width) _x -= this.width;\r\n        while (_x < 0) _x += this.width;\r\n\r\n        const array = this.array;\r\n        const color = this.color;\r\n        const offset = _y * this.width * 4 + _x * 4;\r\n\r\n        color[0] = array[offset];\r\n        color[1] = array[offset + 1];\r\n        color[2] = array[offset + 2];\r\n\r\n        return this.color;\r\n    }\r\n\r\n    getPixelBilinear(x, y) {\r\n        const px = Math.floor(x);\r\n        const py = Math.floor(y);\r\n        const p0 = px + py * this.width;\r\n\r\n        const array = this.array;\r\n        const color = this.color;\r\n\r\n        // Calculate the weights for each pixel\r\n        const fx = x - px;\r\n        const fy = y - py;\r\n        const fx1 = 1 - fx;\r\n        const fy1 = 1 - fy;\r\n\r\n        const w1 = fx1 * fy1;\r\n        const w2 = fx * fy1;\r\n        const w3 = fx1 * fy;\r\n        const w4 = fx * fy;\r\n\r\n        let p1 = p0 * 4; \t\t\t\t\t\t\t// 0 + 0 * w\r\n        let p2 = ( 1 + p0 ) * 4; \t\t\t\t\t// 1 + 0 * w\r\n        let p3 = ( 1 * this.width + p0 ) * 4; \t\t// 0 + 1 * w\r\n        let p4 = ( 1 + 1 * this.width + p0 ) * 4; \t// 1 + 1 * w\r\n\r\n        const len = this.width * this.height * 4;\r\n\r\n        if (p1 >= len) p1 -= len;\r\n        if (p1 < 0) p1 += len;\r\n        if (p2 >= len) p2 -= len;\r\n        if (p2 < 0) p2 += len;\r\n        if (p3 >= len) p3 -= len;\r\n        if (p3 < 0) p3 += len;\r\n        if (p4 >= len) p4 -= len;\r\n        if (p4 < 0) p4 += len;\r\n\r\n        // Calculate the weighted sum of pixels (for each color channel)\r\n        color[0] = array[p1] * w1 + array[p2] * w2 + array[p3] * w3 + array[p4] * w4;\r\n        color[1] = array[p1 + 1] * w1 + array[p2 + 1] * w2 + array[p3 + 1] * w3 + array[p4 + 1] * w4;\r\n        color[2] = array[p1 + 2] * w1 + array[p2 + 2] * w2 + array[p3 + 2] * w3 + array[p4 + 2] * w4;\r\n        color[3] = array[p1 + 3] * w1 + array[p2 + 3] * w2 + array[p3 + 3] * w3 + array[p4 + 3] * w4;\r\n\r\n        return this.color;\r\n    }\r\n\r\n    getPixelOffset(offset) {\r\n        const array = this.array;\r\n        const color = this.color;\r\n\r\n        offset = parseInt(offset * 4);\r\n\r\n        color[0] = array[offset];\r\n        color[1] = array[offset + 1];\r\n        color[2] = array[offset + 2];\r\n        color[3] = array[offset + 3];\r\n\r\n        return this.color;\r\n    }\r\n}\r\n","import {Buffer} from './Buffer';\r\nimport {set} from '../operations/basic';\r\n\r\nexport class Texture {\r\n    constructor(width, height) {\r\n        this.color = new Float32Array(4);\r\n        this.buffer = new Buffer(width, height);\r\n        this.bufferCopy = new Buffer(width, height);\r\n    }\r\n\r\n    toImageData(context) {\r\n        const buffer = this.buffer;\r\n        const array = buffer.array;\r\n\r\n        const imageData = context.createImageData(buffer.width, buffer.height);\r\n        const data = imageData.data;\r\n\r\n        let i;\r\n        const il = array.length;\r\n\r\n        for (i = 0; i < il; i += 4) {\r\n            data[i] = array[i] * 255;\r\n            data[i + 1] = array[i + 1] * 255;\r\n            data[i + 2] = array[i + 2] * 255;\r\n            data[i + 3] = 255;\r\n        }\r\n\r\n        return imageData;\r\n    }\r\n\r\n    toCanvas(canvas) {\r\n        if (canvas === undefined) {\r\n            canvas = document.createElement('canvas');\r\n        }\r\n\r\n        canvas.width = this.buffer.width;\r\n        canvas.height = this.buffer.height;\r\n\r\n        const context = canvas.getContext('2d');\r\n        const imageData = this.toImageData(context);\r\n\r\n        context.putImageData(imageData, 0, 0);\r\n\r\n        return canvas;\r\n    }\r\n\r\n    set(program, operation) {\r\n        this.bufferCopy.copy(this.buffer);\r\n\r\n        const op = operation === undefined ? set : operation;\r\n        const dst = this.buffer;\r\n        const src = this.bufferCopy;\r\n        const color = this.color;\r\n        const tint = program.tint();\r\n\r\n        const array = dst.array;\r\n        const width = dst.width;\r\n        const height = dst.height;\r\n        const il = array.length;\r\n\r\n        let a = 1 - tint[3];\r\n        let b = tint[3];\r\n        let x = 0;\r\n        let y = 0;\r\n        let i;\r\n\r\n        if (tint[3] === 1) {\r\n            for (i = 0; i < il;) {\r\n                program.run(color, x, y, src, width, height);\r\n                array[i] = op(array[i++], color[0] * tint[0]);\r\n                array[i] = op(array[i++], color[1] * tint[1]);\r\n                array[i] = op(array[i++], color[2] * tint[2]);\r\n                i++;\r\n\r\n                if (++x === width) {\r\n                    x = 0;\r\n                    y++;\r\n                }\r\n            }\r\n        } else if (tint[3] !== 0) {\r\n            for (i = 0; i < il;) {\r\n                program.run(color, x, y, src, width, height);\r\n                array[i] = array[i] * a + op(array[i++], color[0] * tint[0]) * b;\r\n                array[i] = array[i] * a + op(array[i++], color[1] * tint[1]) * b;\r\n                array[i] = array[i] * a + op(array[i++], color[2] * tint[2]) * b;\r\n                i++;\r\n\r\n                if (++x === width) {\r\n                    x = 0;\r\n                    y++;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return this;\r\n    }\r\n\r\n    toArrayBuffer() {\r\n        const array = this.buffer.array;\r\n        const il = array.length;\r\n        const buffer = new ArrayBuffer(il);\r\n        const res = new Uint8ClampedArray(buffer);\r\n        let i;\r\n\r\n        for (i = 0; i < il; i += 4) {\r\n            res[i] = array[i] * 255;\r\n            res[i + 1] = array[i + 1] * 255;\r\n            res[i + 2] = array[i + 2] * 255;\r\n            res[i + 3] = 255;\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    static isSingleColor(buffer) {\r\n        const a = new Uint8ClampedArray(buffer);\r\n        const l = a.length;\r\n        let i = 4;\r\n\r\n        while (i < l) {\r\n            if (a[0] !== a[i++] || a[1] !== a[i++] || a[2] !== a[i++]) {\r\n                return false;\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nimport * as operations from '../operations/index';\r\n\r\nfor (let o in operations) {\r\n    if (!Texture.prototype[o]) {\r\n        Texture.prototype[o] = function (program) {\r\n            return this.set(program, operations[o]);\r\n        };\r\n    }\r\n}\r\n","export class Program {\r\n    constructor(proto) {\r\n        // this._tint = new Float32Array([1, 1, 1, 1]);\r\n        this._tint = {\r\n            0: 1, 1: 1, 2: 1, 3: 1, set: function (a) {\r\n                this._tint[0] = a[0];\r\n                this._tint[1] = a[1];\r\n                this._tint[2] = a[2];\r\n                this._tint[3] = a[3];\r\n            }\r\n        };\r\n\r\n        if (proto && proto.params) {\r\n            Object.keys(proto.params).forEach((p) => {\r\n                const v = proto.params[p].val;\r\n\r\n                if (v !== null) {\r\n                    if (Array.isArray(v)) {\r\n                        this[p].apply(this, v);\r\n                    } else {\r\n                        this[p].call(this, v);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    tint(r, g, b, a) {\r\n        if (arguments.length) {\r\n            this._tint[0] = r;\r\n            this._tint[1] = g;\r\n            this._tint[2] = b;\r\n            this._tint[3] = arguments.length > 3 ? a : this._tint[3];\r\n            return this;\r\n        } else {\r\n            return this._tint;\r\n        }\r\n    }\r\n}\r\n\r\nexport const Type = {\r\n    NUMBER: 0,\r\n    INT: 1,\r\n    BOOLEAN: 2,\r\n    INTERPOLATION: 3,\r\n    COLOR_POINT: 4,\r\n    COLOR: 5,\r\n    TEXTURE: 6,\r\n    0: 'NUMBER',\r\n    1: 'INT',\r\n    2: 'BOOLEAN',\r\n    3: 'INTERPOLATION',\r\n    4: 'COLOR_POINT',\r\n    5: 'COLOR',\r\n    6: 'TEXTURE'\r\n};\r\n\r\nexport const EPSILON = Number.EPSILON;\r\n","import {mixColors} from './mixColors';\r\nimport {mirroredWrap, wrap} from './wrap';\r\nimport {clamp} from './clamp';\r\n\r\nexport const ColorInterpolatorMethod = {\r\n    STEP: 0,\r\n    LINEAR: 1,\r\n    SPLINE: 2\r\n};\r\n\r\nexport class ColorInterpolator {\r\n    constructor(method) {\r\n        this.points = [];\r\n        this.low = 0;\r\n        this.high = 0;\r\n        this.interpolation = ( typeof( method ) === 'undefined' ) ? ColorInterpolatorMethod.LINEAR : method;\r\n        this.repeat = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    set(points) {\r\n        this.points = points;\r\n        this.points.sort(function (a, b) {\r\n            return a.pos - b.pos;\r\n        });\r\n\r\n        this.low = this.points[0].pos;\r\n        this.high = this.points[this.points.length - 1].pos;\r\n\r\n        return this;\r\n    }\r\n\r\n    addPoint(position, color) {\r\n\r\n        this.points.push({pos: position, color: color});\r\n        this.points.sort(function (a, b) {\r\n            return a.pos - b.pos;\r\n        });\r\n\r\n        this.low = this.points[0].pos;\r\n        this.high = this.points[this.points.length - 1].pos;\r\n\r\n        return this;\r\n    }\r\n\r\n    setRepeat(value) {\r\n        this.repeat = value;\r\n        return this;\r\n    }\r\n\r\n    setInterpolation(value) {\r\n        this.interpolation = value;\r\n        return this;\r\n    }\r\n\r\n    getColorAt(pos) {\r\n        if (!this.points.length) {\r\n            return [0, 0, 0];\r\n        } else if (this.repeat === 2) {\r\n            pos = mirroredWrap(pos, this.low, this.high);\r\n        }\r\n        else if (this.repeat) {\r\n            pos = wrap(pos, this.low, this.high);\r\n        }\r\n        else {\r\n            pos = clamp(pos, this.low, this.high);\r\n        }\r\n\r\n        let i = 0;\r\n        const points = this.points;\r\n\r\n        while (points[i + 1].pos < pos) i++;\r\n\r\n        const p1 = points[i];\r\n        const p2 = points[i + 1];\r\n\r\n        const delta = ( pos - p1.pos ) / ( p2.pos - p1.pos );\r\n\r\n        if (this.interpolation === ColorInterpolatorMethod.STEP) {\r\n            return p1.color;\r\n        } else if (this.interpolation === ColorInterpolatorMethod.LINEAR) {\r\n            return mixColors(p1.color, p2.color, delta);\r\n        } else if (this.interpolation === ColorInterpolatorMethod.SPLINE) {\r\n            const ar = 2 * p1.color[0] - 2 * p2.color[0];\r\n            const br = -3 * p1.color[0] + 3 * p2.color[0];\r\n            const dr = p1.color[0];\r\n\r\n            const ag = 2 * p1.color[1] - 2 * p2.color[1];\r\n            const bg = -3 * p1.color[1] + 3 * p2.color[1];\r\n            const dg = p1.color[1];\r\n\r\n            const ab = 2 * p1.color[2] - 2 * p2.color[2];\r\n            const bb = -3 * p1.color[2] + 3 * p2.color[2];\r\n            const db = p1.color[2];\r\n\r\n            const delta2 = delta * delta;\r\n            const delta3 = delta2 * delta;\r\n\r\n            return [\r\n                ar * delta3 + br * delta2 + dr,\r\n                ag * delta3 + bg * delta2 + dg,\r\n                ab * delta3 + bb * delta2 + db\r\n            ];\r\n        }\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Number extends Program {\r\n    run(color) {\r\n        color[0] = 1;\r\n        color[1] = 1;\r\n        color[2] = 1;\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class SinX extends Program {\r\n    constructor() {\r\n        super(SinX);\r\n    }\r\n\r\n    size(value) {\r\n        this._size = Math.max(Number.EPSILON, value) / Math.PI / 2;\r\n        return this;\r\n    }\r\n\r\n    offset(value) {\r\n        this._offset = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x) {\r\n        const value = Math.sin(( x + this._offset ) / this._size);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 16,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: 64,\r\n                offset: 16\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class SinY extends Program {\r\n    constructor() {\r\n        super(SinY);\r\n    }\r\n\r\n    size(value) {\r\n        this._size = Math.max(Number.EPSILON, value) / Math.PI / 2;\r\n        return this;\r\n    }\r\n\r\n    offset(value) {\r\n        this._offset = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = Math.sin(( y + this._offset ) / this._size);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 16,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Or extends Program {\r\n    constructor() {\r\n        super(Program);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [Math.max(Number.EPSILON, x), Math.max(Number.EPSILON, y)];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( (256 * x / this._size[0]) | (256 * y / this._size[1]) ) % 256 / 255;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [256, 256],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [64, 64]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Xor extends Program {\r\n    constructor() {\r\n        super(Xor);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [Math.max(Number.EPSILON, x), Math.max(Number.EPSILON, y)];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( 256 * x / this._size[0] ^ 256 * y / this._size[1] ) % 256 / 255;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [256, 256],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [128, 64]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Rect extends Program {\r\n    constructor() {\r\n        super(Rect);\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( x >= this._offset[0] && x <= ( this._offset[0] + this._size[0] ) && y <= ( this._offset[1] + this._size[1] ) && y >= this._offset[1] ) ? 1 : 0;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            size: {\r\n                val: [128, 64],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                offset: [(256 - 128) / 2, (256 - 64) / 2],\r\n                size: [128, 64]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\nimport {distance} from '../../utils/distance';\r\nimport {smoothStep} from '../../utils/smoothStep';\r\n\r\nexport class Circle extends Program {\r\n    constructor() {\r\n        super(Circle);\r\n    }\r\n\r\n    weight(value) {\r\n        this._delta = value;\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    size(value) {\r\n        this._size = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const dist = distance(x, y, this._offset[0], this._offset[1]);\r\n        const value = 1 - smoothStep(this._size - this._delta, this._size, dist);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            size: {\r\n                val: 128,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            weight: {\r\n                val: 1,\r\n                min: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                offset: [128, 128],\r\n                size: 128,\r\n                weight: 32\r\n            },\r\n            {\r\n                offset: [128, 128],\r\n                size: 128,\r\n                weight: 128\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class CheckerBoard extends Program {\r\n    constructor() {\r\n        super(CheckerBoard);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [x, y];\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    shift(value) {\r\n        this._shift = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( ( ( y + this._offset[1] ) / this._size[1] ) & 1 ) ^ ( ( ( x + this._offset[0] + parseInt(y / this._size[1]) * this._shift ) / this._size[0] ) & 1 ) ? 0 : 1;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [32, 32],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            shift: {\r\n                val: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [16, 16],\r\n                offset: [8, 8],\r\n                shift: 0\r\n            },\r\n            {\r\n                size: [64, 16],\r\n                offset: [0, 0],\r\n                shift: 8\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\n\r\nexport class LinearGradient extends Program {\r\n    constructor() {\r\n        super(LinearGradient);\r\n    }\r\n\r\n    size(value) {\r\n        this._size = Math.max(LinearGradient.params.size.min, value);\r\n        return this;\r\n    }\r\n\r\n    repeat(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setRepeat(value);\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    point(position, color) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.addPoint(position, color);\r\n        return this;\r\n    }\r\n\r\n    run(color, x) {\r\n        color.set(this._gradient.getColorAt(x / this._size));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 256,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            repeat: {\r\n                val: true,\r\n                type: Type.BOOLEAN\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            },\r\n            point: {\r\n                val: null,\r\n                type: Type.COLOR_POINT\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                interpolation: ColorInterpolatorMethod.STEP\r\n            },\r\n            {\r\n                interpolation: ColorInterpolatorMethod.SPLINE,\r\n                size: 128\r\n            },\r\n            {\r\n                interpolation: ColorInterpolatorMethod.SPLINE,\r\n                repeat: false,\r\n                size: 32\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\nimport {distance} from '../../utils/distance';\r\n\r\nexport class RadialGradient extends Program {\r\n    constructor() {\r\n        super(RadialGradient);\r\n    }\r\n\r\n    repeat(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setRepeat(value);\r\n        return this;\r\n    }\r\n\r\n    size(value) {\r\n        this._size = value;\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    point(position, color) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.addPoint(position, color);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const dist = distance(x, y, this._offset[0], this._offset[1]);\r\n        color.set(this._gradient.getColorAt(dist / this._size));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 128,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            repeat: {\r\n                val: true,\r\n                type: Type.BOOLEAN\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            },\r\n            point: {\r\n                val: null,\r\n                type: Type.COLOR_POINT\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: 64,\r\n                offset: [128, 128],\r\n                repeat: false\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {hashRNG} from './noiseBase/hashRNG';\r\n\r\nexport class Noise extends Program {\r\n    constructor() {\r\n        super(Noise);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = hashRNG(this._seed, x, y);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\nimport {hashRNG} from './noiseBase/hashRNG';\r\n\r\nexport class NoiseFractal extends Program {\r\n    constructor() {\r\n        super(NoiseFractal);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._baseFrequency = 1 / value;\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._interpolator = this._interpolator || new ColorInterpolator();\r\n        this._interpolator.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        let value = 0;\r\n        let amp = this._amplitude;\r\n        let freq = this._baseFrequency;\r\n        let x1, y1, dx, dy;\r\n        let v1, v2, v3, v4;\r\n        let i1, i2;\r\n\r\n        for (let j = 1; j <= this._octaves; j++) {\r\n            x1 = Math.floor(x * freq);\r\n            y1 = Math.floor(y * freq);\r\n\r\n            if (this._interpolator.interpolation === ColorInterpolatorMethod.STEP) {\r\n                value += hashRNG(this._seed * j, x1, y1) * amp;\r\n            } else {\r\n                dx = ( x * freq ) - x1;\r\n                dy = ( y * freq ) - y1;\r\n\r\n                v1 = hashRNG(this._seed * j, x1, y1);\r\n                v2 = hashRNG(this._seed * j, x1 + 1, y1);\r\n                v3 = hashRNG(this._seed * j, x1, y1 + 1);\r\n                v4 = hashRNG(this._seed * j, x1 + 1, y1 + 1);\r\n\r\n                this._interpolator.set([\r\n                    {pos: 0, color: [v1]},\r\n                    {pos: 1, color: [v2]}\r\n                ]);\r\n\r\n                i1 = this._interpolator.getColorAt(dx);\r\n\r\n                this._interpolator.set([\r\n                    {pos: 0, color: [v3]},\r\n                    {pos: 1, color: [v4]}\r\n                ]);\r\n\r\n                i2 = this._interpolator.getColorAt(dx);\r\n\r\n                this._interpolator.set([\r\n                    {pos: 0, color: [i1[0]]},\r\n                    {pos: 1, color: [i2[0]]}\r\n                ]);\r\n\r\n                value += this._interpolator.getColorAt(dy)[0] * amp;\r\n            }\r\n\r\n            freq *= this._step;\r\n            amp *= this._persistence;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 16,\r\n                min: 0\r\n            },\r\n            amplitude: {\r\n                val: 0.5,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.75,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 3,\r\n                min: 1,\r\n                max: 8\r\n            },\r\n            step: {\r\n                min: 1,\r\n                val: 4,\r\n                max: 16\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                amplitude: 1,\r\n                persistence: 0,\r\n                octaves: 1,\r\n                step: 4,\r\n                interpolation: 2\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 8,\r\n                amplitude: 1,\r\n                persistence: 1,\r\n                octaves: 1,\r\n                step: 4,\r\n                interpolation: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                amplitude: 1,\r\n                persistence: 1,\r\n                octaves: 1,\r\n                step: 4,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                amplitude: 1,\r\n                persistence: 1,\r\n                octaves: 2,\r\n                step: 2,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                amplitude: 0.25,\r\n                persistence: 0.75,\r\n                octaves: 4,\r\n                step: 2,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                amplitude: 0.25,\r\n                persistence: 0.75,\r\n                octaves: 4,\r\n                step: 2,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 3,\r\n                step: 4,\r\n                interpolation: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 3,\r\n                step: 4,\r\n                interpolation: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class CellularNoise extends Program {\r\n    constructor() {\r\n        super(CellularNoise);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const p = cellNoiseBase(x, y, this._seed, this._density, this._weight);\r\n\r\n        let value = 1 - ( p.dist / this._density );\r\n\r\n        if (this._density < 0) {\r\n            value -= 1;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 32,\r\n                min: 0\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: 0\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 16\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 32\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class CellularFractal extends Program {\r\n    constructor() {\r\n        super(CellularFractal);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    scale(value) {\r\n        this._scale = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        let p;\r\n        let value = 0;\r\n        let amp = this._amplitude;\r\n        let dens = this._density;\r\n\r\n        for (let j = 1; j <= this._octaves; j++) {\r\n            p = cellNoiseBase(x * this._scale, y * this._scale, this._seed * j, dens, this._weight);\r\n\r\n            p.dist = 1 - ( p.dist / dens );\r\n            if (dens < 0) p.dist -= 1;\r\n\r\n            value += p.dist * amp;\r\n            dens /= this._step;\r\n            amp *= this._persistence;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 64,\r\n                min: 0\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            amplitude: {\r\n                val: 0.5,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 4,\r\n                min: 1,\r\n                max: 8\r\n            },\r\n            step: {\r\n                val: 2,\r\n                min: 1,\r\n                max: 16\r\n            },\r\n            scale: {\r\n                val: 1,\r\n                scale: false\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 4,\r\n                step: 2\r\n            }, {\r\n                seed: 1,\r\n                density: 32,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 2,\r\n                step: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class VoronoiNoise extends Program {\r\n    constructor() {\r\n        super(VoronoiNoise);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const p = cellNoiseBase(x, y, this._seed, this._density, this._weight);\r\n\r\n        color[0] = p.value;\r\n        color[1] = p.value;\r\n        color[2] = p.value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 32,\r\n                min: EPSILON\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: 0\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 16\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 128\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class VoronoiFractal extends Program {\r\n    constructor() {\r\n        super(VoronoiFractal);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        let p;\r\n        let value = 0;\r\n        let amp = this._amplitude;\r\n        let dens = this._density;\r\n\r\n        for (let j = 1; j <= this._octaves; j++) {\r\n            p = cellNoiseBase(x, y, this._seed * j, dens, this._weight);\r\n\r\n            value += p.value * amp;\r\n            dens /= this._step;\r\n            amp *= this._persistence;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 64,\r\n                min: EPSILON\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: EPSILON,\r\n                max: 2\r\n            },\r\n            amplitude: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 4,\r\n                min: 1,\r\n                max: 8\r\n            },\r\n            step: {\r\n                val: 2,\r\n                min: 1,\r\n                max: 16\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 4,\r\n                step: 2\r\n            }, {\r\n                seed: 1,\r\n                density: 32,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 2,\r\n                step: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","/*\r\n * A speed-improved simplex noise algorithm for 2D, 3D and 4D in JavaScript.\r\n *\r\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\r\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\r\n * Better rank ordering method by Stefan Gustavson in 2012.\r\n *\r\n * This code was placed in the public domain by its original author,\r\n * Stefan Gustavson. You may use it as you see fit, but\r\n * attribution is appreciated.\r\n */\r\nexport default class FastSimplexNoise {\r\n    constructor(options = {}) {\r\n        if (options.hasOwnProperty('amplitude')) {\r\n            this.amplitude = options.amplitude;\r\n        }\r\n        else\r\n            this.amplitude = 1.0;\r\n        if (options.hasOwnProperty('frequency')) {\r\n            this.frequency = options.frequency;\r\n        }\r\n        else\r\n            this.frequency = 1.0;\r\n        if (options.hasOwnProperty('octaves')) {\r\n            this.octaves = options.octaves;\r\n        }\r\n        else\r\n            this.octaves = 1;\r\n        if (options.hasOwnProperty('persistence')) {\r\n            this.persistence = options.persistence;\r\n        }\r\n        else\r\n            this.persistence = 0.5;\r\n        if (options.hasOwnProperty('random')) {\r\n            this.random = options.random;\r\n        }\r\n        else\r\n            this.random = Math.random;\r\n        let min;\r\n        if (options.hasOwnProperty('min')) {\r\n            min = options.min;\r\n        }\r\n        else\r\n            min = -1;\r\n        let max;\r\n        if (options.hasOwnProperty('max')) {\r\n            max = options.max;\r\n        }\r\n        else\r\n            max = 1;\r\n        this.scale = min === -1 && max === 1\r\n            ? value => value\r\n            : value => min + ((value + 1) / 2) * (max - min);\r\n        const p = new Uint8Array(256);\r\n        for (let i = 0; i < 256; i++)\r\n            p[i] = i;\r\n        let n;\r\n        let q;\r\n        for (let i = 255; i > 0; i--) {\r\n            n = Math.floor((i + 1) * this.random());\r\n            q = p[i];\r\n            p[i] = p[n];\r\n            p[n] = q;\r\n        }\r\n        this.perm = new Uint8Array(512);\r\n        this.permMod12 = new Uint8Array(512);\r\n        for (let i = 0; i < 512; i++) {\r\n            this.perm[i] = p[i & 255];\r\n            this.permMod12[i] = this.perm[i] % 12;\r\n        }\r\n    }\r\n\r\n    dot(gs, coords) {\r\n        return gs\r\n            .slice(0, Math.min(gs.length, coords.length))\r\n            .reduce((total, g, i) => total + (g * coords[i]), 0);\r\n    }\r\n\r\n    raw2D(x, y) {\r\n        // Skew the input space to determine which simplex cell we're in\r\n        const s = (x + y) * 0.5 * (Math.sqrt(3.0) - 1.0); // Hairy factor for 2D\r\n        const i = Math.floor(x + s);\r\n        const j = Math.floor(y + s);\r\n        const t = (i + j) * FastSimplexNoise.G2;\r\n        const X0 = i - t; // Unskew the cell origin back to (x,y) space\r\n        const Y0 = j - t;\r\n        const x0 = x - X0; // The x,y distances from the cell origin\r\n        const y0 = y - Y0;\r\n        // Determine which simplex we are in.\r\n        const i1 = x0 > y0 ? 1 : 0;\r\n        const j1 = x0 > y0 ? 0 : 1;\r\n        // Offsets for corners\r\n        const x1 = x0 - i1 + FastSimplexNoise.G2;\r\n        const y1 = y0 - j1 + FastSimplexNoise.G2;\r\n        const x2 = x0 - 1.0 + 2.0 * FastSimplexNoise.G2;\r\n        const y2 = y0 - 1.0 + 2.0 * FastSimplexNoise.G2;\r\n        // Work out the hashed gradient indices of the three simplex corners\r\n        const ii = i & 255;\r\n        const jj = j & 255;\r\n        const gi0 = this.permMod12[ii + this.perm[jj]];\r\n        const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];\r\n        const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];\r\n        // Calculate the contribution from the three corners\r\n        const t0 = 0.5 - x0 * x0 - y0 * y0;\r\n        const n0 = t0 < 0 ? 0.0 : Math.pow(t0, 4) * this.dot(FastSimplexNoise.GRAD3D[gi0], [x0, y0]);\r\n        const t1 = 0.5 - x1 * x1 - y1 * y1;\r\n        const n1 = t1 < 0 ? 0.0 : Math.pow(t1, 4) * this.dot(FastSimplexNoise.GRAD3D[gi1], [x1, y1]);\r\n        const t2 = 0.5 - x2 * x2 - y2 * y2;\r\n        const n2 = t2 < 0 ? 0.0 : Math.pow(t2, 4) * this.dot(FastSimplexNoise.GRAD3D[gi2], [x2, y2]);\r\n        // Add contributions from each corner to get the final noise value.\r\n        // The result is scaled to return values in the interval [-1, 1]\r\n        return 70.14805770653952 * (n0 + n1 + n2);\r\n    }\r\n\r\n    scaled2D(x, y) {\r\n        let amplitude = this.amplitude;\r\n        let frequency = this.frequency;\r\n        let maxAmplitude = 0;\r\n        let noise = 0;\r\n        for (let i = 0; i < this.octaves; i++) {\r\n            noise += this.raw2D(x * frequency, y * frequency) * amplitude;\r\n            maxAmplitude += amplitude;\r\n            amplitude *= this.persistence;\r\n            frequency *= 2;\r\n        }\r\n        return this.scale(noise / maxAmplitude);\r\n    }\r\n}\r\nFastSimplexNoise.G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\r\nFastSimplexNoise.GRAD3D = [\r\n    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],\r\n    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],\r\n    [0, 1, 1], [0, -1, -1], [0, 1, -1], [0, -1, -1]\r\n];\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport FastSimplexNoise from './simplexNoiseBase/FastSimplexNoise';\r\nimport {hashRNG} from './noiseBase/hashRNG';\r\n\r\nexport class SimplexNoise extends Program {\r\n    constructor() {\r\n        super(SimplexNoise);\r\n        this._count = 0;\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        this._base = this._base || new FastSimplexNoise({\r\n                min: 0,\r\n                max: 1,\r\n                frequency: 1 / this._density,\r\n                octaves: this._octaves,\r\n                amplitude: this._amplitude,\r\n                persistence: this._persistence,\r\n                random: function () {\r\n                    return hashRNG(this._seed, this._count++, 0);\r\n                }\r\n            });\r\n\r\n        const value = this._base.scaled2D(x, y);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 16,\r\n                min: EPSILON\r\n            },\r\n            amplitude: {\r\n                val: 1,\r\n                min: EPSILON,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 1,\r\n                min: 1,\r\n                max: 8\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 128,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 8\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 128,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 5\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 12,\r\n                amplitude: 0.25,\r\n                persistence: 1,\r\n                octaves: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Abs extends Program {\r\n    run(color, x, y, src) {\r\n        const value = src.getPixelNearest(x, y);\r\n        color[0] = Math.abs(value[0]);\r\n        color[1] = Math.abs(value[1]);\r\n        color[2] = Math.abs(value[2]);\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Copy extends Program {\r\n    run(color, x, y, src) {\r\n        const value = src.getPixelNearest(x, y);\r\n        color.set(value);\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {clamp} from \"../../utils/clamp\";\r\n\r\nexport class Convolution extends Program {\r\n    constructor() {\r\n        super(Convolution);\r\n    }\r\n\r\n    preset(value) {\r\n        this._weights = Convolution.Presets[value] || Convolution.Presets[0];\r\n        this._side = Math.round(Math.sqrt(this._weights.length));\r\n        this._halfSide = Math.floor(this._side / 2);\r\n        return this;\r\n    }\r\n\r\n    static get Presets() {\r\n        return {\r\n            0: [0, -1, 0,\r\n                -1, 5, -1,\r\n                0, -1, 0],\r\n            1: [1 / 9, 1 / 9, 1 / 9,\r\n                1 / 9, 1 / 9, 1 / 9,\r\n                1 / 9, 1 / 9, 1 / 9],\r\n            2: [1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25],\r\n            3: [2, 1, 0,\r\n                1, 1, -1,\r\n                0, -1, -2],\r\n            4: [0, 1, 0,\r\n                1, -4, 1,\r\n                0, 1, 0]\r\n        };\r\n    }\r\n\r\n    run(color, x, y, src, width, height) {\r\n        const sy = y;\r\n        const sx = x;\r\n        let r = 0, g = 0, b = 0;\r\n\r\n        for (let cy = 0; cy < this._side; cy++) {\r\n            for (let cx = 0; cx < this._side; cx++) {\r\n                const scy = sy + cy - this._halfSide;\r\n                const scx = sx + cx - this._halfSide;\r\n                const wt = this._weights[cy * this._side + cx];\r\n                const value = src.getPixelNearest(clamp(scx, 0, width - 1), clamp(scy, 0, height - 1));\r\n                r += value[0] * wt;\r\n                g += value[1] * wt;\r\n                b += value[2] * wt;\r\n            }\r\n        }\r\n\r\n        color[0] = r;\r\n        color[1] = g;\r\n        color[2] = b;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            preset: {\r\n                val: 0,\r\n                min: 0,\r\n                max: 4,\r\n                type: Type.INT\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                preset: 1\r\n            },\r\n            {\r\n                preset: 2\r\n            },\r\n            {\r\n                preset: 3\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport FastSimplexNoise from \"../generators/simplexNoiseBase/FastSimplexNoise\";\r\nimport {hashRNG} from \"../generators/noiseBase/hashRNG\";\r\n\r\nexport class Distort extends Program {\r\n    constructor() {\r\n        super(Distort);\r\n        this._count = 0;\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        this._base = this._base || new FastSimplexNoise({\r\n                min: -1,\r\n                max: 1,\r\n                frequency: 1 / this._density,\r\n                octaves: this._octaves,\r\n                amplitude: this._amplitude,\r\n                persistence: this._persistence,\r\n                random: function () {\r\n                    return hashRNG(this._seed, this._count++, 0);\r\n                }\r\n            });\r\n\r\n        const value = this._base.scaled2D(x, y);\r\n        const s = x + this._weight * value;\r\n        const t = y + this._weight * value;\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 32,\r\n                min: EPSILON\r\n            },\r\n            amplitude: {\r\n                val: 1,\r\n                min: EPSILON,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 1,\r\n                min: 1,\r\n                type: Type.INT,\r\n                max: 8\r\n            },\r\n            weight: {\r\n                val: 4,\r\n                min: Number.EPSILON\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 128,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 1,\r\n                weight: 32\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 1,\r\n                weight: 32\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\n\r\nexport class GradientMap extends Program {\r\n    repeat(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setRepeat(value);\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    point(position, color) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.addPoint(position, color);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const v = src.getPixelNearest(x, y);\r\n\r\n        const r = this._gradient.getColorAt(v[0])[0];\r\n        const g = this._gradient.getColorAt(v[1])[1];\r\n        const b = this._gradient.getColorAt(v[2])[2];\r\n\r\n        color[0] = r;\r\n        color[1] = g;\r\n        color[2] = b;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            repeat: {\r\n                val: true,\r\n                type: Type.BOOLEAN\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            },\r\n            point: {\r\n                val: null,\r\n                type: Type.COLOR_POINT\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Grayscale extends Program {\r\n    run(color, x, y, src) {\r\n        const value = src.getPixelNearest(x, y);\r\n        const g = .2126 * value[0] + .7152 * value[1] + .0722 * value[2];\r\n        color[0] = g;\r\n        color[1] = g;\r\n        color[2] = g;\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Normalize extends Program {\r\n    multiplier(value) {\r\n        this._multiplier = value;\r\n        return this;\r\n    }\r\n\r\n    offset(value) {\r\n        this._offset = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        if (!this._init) {\r\n            let high = -Infinity;\r\n            let low = Infinity;\r\n\r\n            let j = 0;\r\n            const len = src.array.length;\r\n            for (; j < len; j++) {\r\n                if (j % 4 === 3) continue;\r\n\r\n                high = ( src.array[j] > high ) ? src.array[j] : high;\r\n                low = ( src.array[j] < low  ) ? src.array[j] : low;\r\n            }\r\n\r\n            this._offset = -low;\r\n            this._multiplier = 1 / ( high - low );\r\n            this._init = true;\r\n        }\r\n\r\n        const v = src.getPixelNearest(x, y);\r\n        color[0] = ( v[0] + this._offset ) * this._multiplier;\r\n        color[1] = ( v[1] + this._offset ) * this._multiplier;\r\n        color[2] = ( v[2] + this._offset ) * this._multiplier;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            multiplier: {\r\n                val: 1\r\n            },\r\n            offset: {\r\n                val: 0\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\n\r\nexport class Pixelate extends Program {\r\n    constructor() {\r\n        super(Pixelate);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const s = this._size[0] * Math.floor(x / this._size[0]);\r\n        const t = this._size[1] * Math.floor(y / this._size[1]);\r\n\r\n        color.set(src.getPixelNearest(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [2, 2],\r\n                type: Type.INT,\r\n                min: 2,\r\n                max: 256\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Posterize extends Program {\r\n    constructor() {\r\n        super(Posterize);\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(value, 2);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const v = src.getPixelNearest(x, y);\r\n        color[0] = Math.floor(Math.floor(v[0] * 255 / ( 255 / this._step )) * 255 / ( this._step - 1 )) / 255;\r\n        color[1] = Math.floor(Math.floor(v[1] * 255 / ( 255 / this._step )) * 255 / ( this._step - 1 )) / 255;\r\n        color[2] = Math.floor(Math.floor(v[2] * 255 / ( 255 / this._step )) * 255 / ( this._step - 1 )) / 255;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            step: {\r\n                val: 2\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {EPSILON, Program} from '../../core/Program';\r\n\r\nexport class SineDistort extends Program {\r\n    constructor() {\r\n        super(SineDistort);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [Math.max(Number.EPSILON, x) / Math.PI / 2, Math.max(Number.EPSILON, y) / Math.PI / 2];\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    amplitude(x, y) {\r\n        this._amplitude = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const s = x + Math.sin(y / this._size[0] + this._offset[0]) * this._amplitude[0];\r\n        const t = y + Math.sin(x / this._size[1] + this._offset[1]) * this._amplitude[1];\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {val: [32, 32], min: EPSILON},\r\n            offset: {val: [0, 0]},\r\n            amplitude: {val: [8, 8], min: EPSILON}\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [128, 128],\r\n                offset: [0, 0],\r\n                amplitude: [64, 64],\r\n            },\r\n            {\r\n                size: [256, 256],\r\n                offset: [0, 0],\r\n                amplitude: [32, 32],\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\nimport {deg2rad} from '../../utils/deg2rad';\r\n\r\nexport class Transform extends Program {\r\n    constructor() {\r\n        super(Transform);\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    angle(value) {\r\n        this._angle = deg2rad(value);\r\n        return this;\r\n    }\r\n\r\n    scale(x, y) {\r\n        if (x === 0 || y === 0) return;\r\n        this._scale = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src, width, height) {\r\n        const x2 = x - width / 2;\r\n        const y2 = y - height / 2;\r\n\r\n        let s = x2 * ( Math.cos(this._angle) / this._scale[0] ) + y2 * -( Math.sin(this._angle) / this._scale[0] );\r\n        let t = x2 * ( Math.sin(this._angle) / this._scale[1] ) + y2 * ( Math.cos(this._angle) / this._scale[1] );\r\n\r\n        s += this._offset[0] + width / 2;\r\n        t += this._offset[1] + height / 2;\r\n\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {val: [0, 0]},\r\n            angle: {val: 0, min: 0, max: 360},\r\n            scale: {val: [1, 1]}\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                offset: [0, 0],\r\n                angle: 45,\r\n                scale: [2, 2]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\nimport {distance} from '../../utils/distance';\r\n\r\nexport class Twirl extends Program {\r\n    constructor() {\r\n        super(Twirl);\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = value;\r\n        return this;\r\n    }\r\n\r\n    size(value) {\r\n        this._size = value;\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        let dist = distance(x, y, this._offset[0], this._offset[1]);\r\n        let s, t;\r\n\r\n        // no distortion if outside of whirl size.\r\n        if (dist < this._size) {\r\n            dist = Math.pow(this._size - dist, 2) / this._size;\r\n\r\n            const angle = 2.0 * Math.PI * (dist / (this._size / this._weight));\r\n            s = (((x - this._offset[0]) * Math.cos(angle)) - ((y - this._offset[0]) * Math.sin(angle)) + this._offset[0] + 0.5);\r\n            t = (((y - this._offset[1]) * Math.cos(angle)) + ((x - this._offset[1]) * Math.sin(angle)) + this._offset[1] + 0.5);\r\n        } else {\r\n            s = x;\r\n            t = y;\r\n        }\r\n\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            weight: {\r\n                val: 0.5,\r\n                min: -1,\r\n                max: 1\r\n            },\r\n            size: {\r\n                val: 128\r\n            },\r\n            offset: {\r\n                val: [128, 128]\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {mirroredWrap, wrap} from '../../utils/wrap';\r\nimport {clamp} from '../../utils/clamp';\r\n\r\nexport class PutTexture extends Program {\r\n    constructor() {\r\n        super(PutTexture);\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    repeat(value) {\r\n        this._repeat = value;\r\n        return this;\r\n    }\r\n\r\n    texture(value) {\r\n        this._srcTex = value.buffer;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        this._srcTex = this._srcTex || src;\r\n        const texWidth = this._srcTex.width;\r\n        const texHeight = this._srcTex.height;\r\n\r\n        const texX = Math.floor(x - this._offset[0]);\r\n        const texY = Math.floor(y - this._offset[1]);\r\n\r\n        if (texX >= texWidth || texY >= texHeight || texX < 0 || texY < 0) {\r\n            if (this._repeat) {\r\n                let nx, ny;\r\n                const rangeX = texWidth - 1;\r\n                const rangeY = texHeight - 1;\r\n\r\n                if (this._repeat === 1) {\r\n                    nx = wrap(texX, 0, texWidth);\r\n                    ny = wrap(texY, 0, texHeight);\r\n                } else if (this._repeat === 2) {\r\n                    nx = mirroredWrap(texX, 0, rangeX);\r\n                    ny = mirroredWrap(texY, 0, rangeY);\r\n                } else if (this._repeat === 3) {\r\n                    nx = clamp(texX, 0, rangeX);\r\n                    ny = clamp(texY, 0, rangeY);\r\n                }\r\n\r\n                color.set(this._srcTex.getPixelNearest(nx, ny));\r\n            } else {\r\n                color[0] = 0;\r\n                color[1] = 0;\r\n                color[2] = 0;\r\n            }\r\n        } else {\r\n            color.set(this._srcTex.getPixelNearest(texX, texY));\r\n        }\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {\r\n                val: [0, 0]\r\n            },\r\n            repeat: {\r\n                val: false,\r\n                type: Type.BOOLEAN\r\n            },\r\n            texture: {\r\n                val: null,\r\n                type: Type.TEXTURE\r\n            }\r\n        };\r\n    }\r\n}\r\n","import * as Generators from './generators/index';\r\nimport * as Filters from './filters/index';\r\nimport * as Mixers from './mixers/index';\r\n\r\nexport const Programs = {\r\n    Generators: Generators,\r\n    Filters: Filters,\r\n    Mixers: Mixers\r\n};\r\n","export {Texture} from './core/Texture';\r\nexport {Buffer} from './core/Buffer';\r\nexport {Program, Type, EPSILON} from './core/Program';\r\n\r\nexport {ColorInterpolatorMethod} from './utils/ColorInterpolator';\r\n\r\nexport * from './programs/generators/index';\r\nexport * from './programs/filters/index';\r\nexport * from './programs/mixers/index';\r\n\r\nimport * as operations from './operations/index';\r\nexport const Operations = operations;\r\nexport {Programs} from './programs/index';\r\n\r\nexport {bufferToCanvas} from './utils/bufferToCanvas';\r\n\r\nexport const version = '2.0.0';\r\n","export const WIDTH = 'w';\r\nexport const HEIGHT = 'h';\r\n","// importScripts('../texgen/texgen.js');\r\nimport * as TG from '../texgen'\r\n\r\nimport {bodyToFunction} from '../texgen-recipe'\r\n\r\nself.TG = TG;\r\n\r\nself.addEventListener('message', function (e) {\r\n    const data = e.data;\r\n    const fnc = bodyToFunction(data.fnc);\r\n\r\n    let passed = true;\r\n    let texture;\r\n    let time;\r\n    let buffer;\r\n\r\n    if (data.test) {\r\n        texture = fnc(data.test[0], data.test[1]);\r\n        passed = !TG.Texture.isSingleColor(texture.toArrayBuffer());\r\n    }\r\n\r\n    if (passed) {\r\n        time = performance.now();\r\n        buffer = fnc(data.width, data.height).toArrayBuffer();\r\n        time = performance.now() - time;\r\n    }\r\n\r\n    const ret = {\r\n        buffer: buffer,\r\n        passed: passed,\r\n        time: time,\r\n        version: TG.version\r\n    };\r\n\r\n    Object.keys(data).forEach(function (k) {\r\n        ret[k] = data[k];\r\n    });\r\n\r\n    if (buffer) {\r\n        self.postMessage(ret, [buffer])\r\n    } else {\r\n        self.postMessage(ret)\r\n    }\r\n});\r\n"],"names":["set","x","y","add","sub","mul","div","and","xor","min","Math","max","average","a","b","screen","overlay","linearBurn","colorBurn","colorDodge","difference","abs","exclusion","softLight","hardLight","vividLight","linearLight","pinLight","mixColors","c1","c2","delta","wrap","value","v","r","mirroredWrap","clamp","distance","x0","y0","x1","y1","dx","dy","sqrt","smoothStep","edge0","edge1","xx","hashRNG","seed","s","cellNoiseBase","density","weight","qx","qy","rx","ry","w","px","py","dist","shortest","Infinity","sx","sy","ceil","deg2rad","deg","dr","bufferToCanvas","buffer","width","height","canvas","can","document","createElement","ctx","getContext","imageData","getImageData","data","heap","Uint8Array","last","length","i","putImageData","bodyToFunction","body","Function","WIDTH","HEIGHT","Buffer","array","Float32Array","color","_x","round","_y","this","offset","floor","p0","fx","fy","fx1","fy1","w1","w2","w3","w4","p1","p2","p3","p4","len","parseInt","Texture","bufferCopy","context","createImageData","il","undefined","toImageData","program","operation","copy","op","dst","src","tint","run","ArrayBuffer","res","Uint8ClampedArray","l","o","prototype","operations","Program","proto","_tint","1","2","3","params","keys","forEach","p","val","Array","isArray","apply","call","g","arguments","Type","EPSILON","Number","ColorInterpolatorMethod","ColorInterpolator","method","points","low","high","interpolation","LINEAR","repeat","sort","pos","position","push","STEP","SPLINE","ar","br","ag","bg","dg","ab","bb","db","delta2","delta3","SinX","_size","PI","_offset","sin","SinY","Or","Xor","Rect","Circle","_delta","CheckerBoard","_shift","LinearGradient","size","_gradient","setRepeat","setInterpolation","addPoint","getColorAt","BOOLEAN","INTERPOLATION","COLOR_POINT","RadialGradient","Noise","_seed","INT","NoiseFractal","_baseFrequency","_amplitude","_persistence","_octaves","_step","_interpolator","amp","freq","v1","v2","v3","v4","i1","i2","j","CellularNoise","_density","_weight","CellularFractal","_scale","dens","VoronoiNoise","VoronoiFractal","FastSimplexNoise","options","hasOwnProperty","amplitude","frequency","octaves","persistence","random","scale","n","q","perm","permMod12","gs","coords","slice","reduce","total","t","G2","X0","Y0","j1","x2","y2","ii","jj","gi0","gi1","gi2","t0","n0","pow","dot","GRAD3D","t1","n1","t2","n2","maxAmplitude","noise","raw2D","SimplexNoise","_count","_base","scaled2D","Abs","getPixelNearest","Copy","Convolution","_weights","Presets","_side","_halfSide","cy","cx","scy","scx","wt","Distort","getPixelBilinear","GradientMap","Grayscale","Normalize","_multiplier","_init","Pixelate","Posterize","SineDistort","Transform","_angle","cos","Twirl","angle","PutTexture","_repeat","_srcTex","texWidth","texHeight","texX","texY","nx","ny","rangeX","rangeY","TEXTURE","Programs","Generators","Filters","Mixers","Operations","version","self","TG","addEventListener","e","fnc","passed","texture","time","test","isSingleColor","toArrayBuffer","performance","now","ret","k","postMessage"],"mappings":"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"}