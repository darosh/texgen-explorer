{"version":3,"file":"texgen-generator.js","sources":["getRef.js","traverse.js","getRandom.js","../texgen-schema/getSchema.js","getProgram.js","getFeatures.js","../../node_modules/d3-random/src/uniform.js","colors.js"],"sourcesContent":["export function getRef($ref, schema) {\r\n    let parts = $ref.slice(2).split('/');\r\n    let x = schema;\r\n\r\n    parts.forEach((part) => {\r\n        x = x[part];\r\n    });\r\n\r\n    return x;\r\n}\r\n","import {getRef} from \"./getRef\";\r\nimport {randomUniform} from \"d3-random\";\r\n\r\nexport function traverse(current, root = null) {\r\n    let c = current;\r\n    let r = root || current;\r\n    let result = {};\r\n\r\n    if (!c) {\r\n        throw new Error();\r\n    }\r\n\r\n    if (c.$ref) {\r\n        c = getRef(c.$ref, r);\r\n    }\r\n\r\n    // if (c.default) {\r\n    //     return c.default;\r\n    // }\r\n\r\n    if (c.enum) {\r\n        return c.enum[Math.floor(randomUniform(c.enum.length)())];\r\n    }\r\n\r\n    if (c.type === 'number') {\r\n        return parseFloat(randomUniform(c.minimum || Number.MIN_VALUE, c.maximum || Number.MAX_VALUE)().toPrecision(2));\r\n        // return rand(c.minimum, c.default, c.maximum);\r\n    } else if (c.type === 'integer') {\r\n        return Math.floor(randomUniform(c.minimum || Number.MIN_VALUE, c.maximum || Number.MAX_VALUE)());\r\n        // return  Math.floor(rand(c.minimum, c.default, c.maximum));\r\n    } else if (c.type === 'boolean') {\r\n        return Math.floor(randomUniform(2)()) === 1;\r\n    } else if (c.type === 'array') {\r\n        let items = c.items.length\r\n        || Math.min((c.maxItems || 8), Math.floor(randomUniform(c.minItems || 1, (c.maxItems || 8) + 1)()));\r\n\r\n        result = [];\r\n\r\n        for (let i = 0; i < items; i++) {\r\n            let item = c.items.length ? c.items[i] : c.items;\r\n            let value = traverse(item, r);\r\n\r\n            result.push(value);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    if (c.anyOf) {\r\n        let picked = c.anyOf[Math.floor(randomUniform(c.anyOf.length)())];\r\n        return traverse(picked, r);\r\n    }\r\n\r\n    if (c.properties) {\r\n        Object.keys(c.properties).forEach((prop) => {\r\n            result[prop] = traverse(c.properties[prop], r);\r\n        });\r\n    }\r\n\r\n    return result;\r\n}\r\n","import {getSchema} from '../texgen-schema';\r\nimport {traverse} from \"./traverse\";\r\n\r\nexport function getRandom() {\r\n    var r = traverse(getSchema());\r\n\r\n    if (!TG.Programs.Generators[r.render[0].program.type]) {\r\n        r.render[0].program = {\r\n            type: 'Number'\r\n        }\r\n    }\r\n\r\n    return r;\r\n}\r\n","let schema = null;\r\n\r\nimport * as TG from '../texgen';\r\n\r\nexport function getSchema() {\r\n    if (schema) {\r\n        return schema;\r\n    }\r\n\r\n    const s = {\r\n        type: \"object\",\r\n        properties: {\r\n            render: {\r\n                $ref: \"#/definitions/texture\"\r\n            }\r\n        },\r\n        required: [\r\n            \"render\"\r\n        ],\r\n        definitions: {\r\n            operation: {},\r\n            texture: {\r\n                type: \"array\",\r\n                minItems: 3,\r\n                maxItems: 7,\r\n                items: {\r\n                    type: \"object\",\r\n                    properties: {\r\n                        operation: {\r\n                            $ref: \"#/definitions/operation\"\r\n                        },\r\n                        tint: {\r\n                            $ref: \"#/definitions/tint\"\r\n                        },\r\n                        program: {\r\n                            anyOf: []\r\n                        }\r\n                    },\r\n                    required: [\r\n                        \"operation\",\r\n                        \"program\"\r\n                    ]\r\n                }\r\n\r\n            },\r\n            tint: {\r\n                type: \"array\",\r\n                minItems: 3,\r\n                maxItems: 4,\r\n                items: {\r\n                    type: \"number\",\r\n                    minimum: 0,\r\n                    maximum: 1,\r\n                    'default': 0.5\r\n                }\r\n            },\r\n            color: {\r\n                type: \"array\",\r\n                minItems: 3,\r\n                maxItems: 3,\r\n                items: {\r\n                    type: \"number\",\r\n                    minimum: 0,\r\n                    maximum: 1,\r\n                    'default': 0.5\r\n                }\r\n            },\r\n            point: {\r\n                type: \"array\",\r\n                minItems: 2,\r\n                maxItems: 8,\r\n                items: {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            type: \"number\",\r\n                            minimum: 0,\r\n                            maximum: 1,\r\n                            'default': 0.5\r\n                        },\r\n                        {\r\n                            $ref: \"#/definitions/color\"\r\n                        }\r\n                    ]\r\n                },\r\n                'default': [[0, [0, 0, 0]], [.4, [1, 1, 1]], [.6, [1, 1, 1]], [1, [0, 0, 0]]]\r\n            },\r\n            interpolation: {\r\n                'enum': [\r\n                    0,\r\n                    1,\r\n                    2\r\n                ],\r\n                'default': 1\r\n            }\r\n        }\r\n    };\r\n\r\n    s.definitions.operation.enum = Object.keys(TG.Operations);\r\n\r\n    let r = s.definitions.texture.items.properties.program.anyOf;\r\n\r\n    addPrograms(s, 'generators', TG.Programs.Generators, r, TG);\r\n    addPrograms(s, 'filters', TG.Programs.Filters, r, TG);\r\n    addPrograms(s, 'mixers', TG.Programs.Mixers, r, TG);\r\n\r\n    schema = s;\r\n\r\n    return s;\r\n}\r\n\r\nfunction addPrograms(s, n, l, r, TG) {\r\n    Object.keys(l).forEach((k) => {\r\n        r.push({\r\n            $ref: '#/definitions/' + n + '/definitions/' + k\r\n        });\r\n\r\n        s.definitions[n] = s.definitions[n] || {definitions: {}};\r\n\r\n        let o = s.definitions[n].definitions[k] = {\r\n            properties: {\r\n                type: {\r\n                    enum: [k]\r\n                }\r\n            },\r\n            required: ['type']\r\n        };\r\n\r\n        if (l[k].params) {\r\n            Object.keys(l[k].params).forEach((p) => {\r\n                let q = o.properties[p] = {};\r\n                let t = l[k].params[p];\r\n                let pt = {\r\n                    isArray: Array.isArray(t.val),\r\n                    type: t.type || 0,\r\n                    min: !isNaN(t.min) ? t.min : -256,\r\n                    max: !isNaN(t.max) ? t.max : 256,\r\n                    length: Array.isArray(t.val) ? t.val.length : 1,\r\n                    val: t.val\r\n                };\r\n\r\n                if (pt.isArray) {\r\n                    q.type = 'array';\r\n                    q.items = {\r\n                        type: pt.type ? 'number' : 'integer',\r\n                        minimum: pt.min,\r\n                        maximum: pt.max\r\n                    };\r\n\r\n                    q.minItems = pt.length;\r\n                    q.maxItems = pt.length;\r\n                } else if (pt.type === TG.Type.BOOLEAN) {\r\n                    q.type = 'boolean';\r\n                } else if (pt.type === TG.Type.COLOR_POINT) {\r\n                    q.$ref = '#/definitions/point';\r\n                } else if (pt.type === TG.Type.INTERPOLATION) {\r\n                    q.$ref = '#/definitions/interpolation';\r\n                } else if (pt.type === TG.Type.NUMBER) {\r\n                    q.type = 'number';\r\n                    q.minimum = pt.min;\r\n                    q.maximum = pt.max;\r\n                } else if (pt.type === TG.Type.INT) {\r\n                    q.type = 'integer';\r\n                    q.minimum = pt.min;\r\n                    q.maximum = pt.max;\r\n                }\r\n\r\n                q.default = pt.val;\r\n            })\r\n        }\r\n\r\n        if (k === 'PutTexture') {\r\n            o.properties.texture = {\r\n                $ref: \"#/definitions/texture\"\r\n            };\r\n        }\r\n    });\r\n}\r\n","import {getRef} from \"./getRef\";\r\n\r\nexport function getProgram(tt, schema) {\r\n    let pr = {\r\n        type: tt.properties['type'].enum[0]\r\n    };\r\n\r\n    Object.keys(tt.properties)\r\n        .filter(function (p) {\r\n            return p !== 'type'\r\n        })\r\n        .forEach(function (p) {\r\n            let c = tt.properties[p];\r\n\r\n            if (c.$ref) {\r\n                c = getRef(c.$ref, schema);\r\n            }\r\n\r\n            if (c.default !== undefined) {\r\n                pr[p] = c.default;\r\n            }\r\n        });\r\n\r\n    return pr;\r\n}\r\n","import {getSchema} from '../texgen-schema/getSchema';\r\nimport {colors} from './colors';\r\nimport {getProgram} from './getProgram';\r\nimport * as TG from '../texgen';\r\n\r\nconst baseId = 1;\r\nconst mixId = 3;\r\n\r\nexport function getFeatures() {\r\n    const schema = getSchema();\r\n    let ret = [];\r\n    addGenerators(ret, schema.definitions['generators'].definitions, schema);\r\n    addFilters(ret, {...ret[baseId].render[0], ...{tint: [1, 1, 1]}}, schema.definitions['filters'].definitions, schema);\r\n    addMixers(ret, {...ret[baseId].render[0]}, {...ret[mixId].render[0]});\r\n    addOperations(ret, {...ret[baseId].render[0], ...{tint: [1, 1, 0.5]}}, {...ret[mixId].render[0]}, schema.definitions['operation'].enum);\r\n    addAlphas(ret, {...ret[baseId].render[0], ...{tint: [1, 1, 0.5]}}, {...ret[mixId].render[0]});\r\n    return ret;\r\n}\r\n\r\nfunction addGenerators(ret, defs, schema) {\r\n    let color = 0;\r\n    let keys = Object.keys(defs);\r\n    keys.forEach(function (k) {\r\n        let tt = defs[k];\r\n        let pr = getProgram(tt, schema);\r\n\r\n        ret.push({\r\n            title: k,\r\n            group: 'Generators',\r\n            render: [\r\n                {\r\n                    tint: colors[color++ % colors.length],\r\n                    operation: 'set',\r\n                    program: pr\r\n                }\r\n            ]\r\n        });\r\n\r\n\r\n        if (TG[k] && TG[k].examples) {\r\n            TG[k].examples.forEach(function (e, i) {\r\n                let pr = getProgram(tt, schema);\r\n\r\n                Object.keys(e).forEach(function (k) {\r\n                    pr[k] = e[k];\r\n                });\r\n\r\n                ret.push({\r\n                    title: k,\r\n                    subTitle: '#' + (i + 1),\r\n                    group: 'Generators',\r\n                    render: [\r\n                        {\r\n                            tint: colors[color++ % colors.length],\r\n                            operation: 'set',\r\n                            program: pr\r\n                        }\r\n                    ]\r\n                });\r\n            })\r\n        }\r\n    });\r\n}\r\n\r\nfunction addFilters(ret, base, defs, schema) {\r\n    const keys = Object.keys(defs);\r\n    keys.map(function (k) {\r\n        let tt = defs[k];\r\n        let pr = getProgram(tt, schema);\r\n\r\n        ret.push({\r\n            title: k,\r\n            group: 'Filters',\r\n            render: [\r\n                base,\r\n                {\r\n                    tint: [1, 1, 1],\r\n                    operation: 'set',\r\n                    program: pr\r\n                }\r\n            ]\r\n        });\r\n\r\n        if (TG[k] && TG[k].examples) {\r\n            TG[k].examples.forEach(function (e, i) {\r\n                let pr = getProgram(tt, schema);\r\n\r\n                Object.keys(e).forEach(function (k) {\r\n                    pr[k] = e[k];\r\n                });\r\n\r\n                ret.push({\r\n                    title: k,\r\n                    subTitle: '#' + (i + 1),\r\n                    group: 'Filters',\r\n                    render: [\r\n                        base,\r\n                        {\r\n                            tint: [1, 1, 1],\r\n                            operation: 'set',\r\n                            program: pr\r\n                        }\r\n                    ]\r\n                });\r\n            })\r\n        }\r\n    });\r\n}\r\n\r\nfunction addMixers(ret, base, mix) {\r\n    ret.push({\r\n        title: 'PutTexture',\r\n        group: 'Mixers',\r\n        render: [\r\n            base,\r\n            {\r\n                tint: [1, 1, 1],\r\n                operation: 'add',\r\n                program: {\r\n                    type: 'PutTexture',\r\n                    texture: [mix]\r\n                }\r\n            }\r\n        ]\r\n    });\r\n}\r\n\r\nfunction addOperations(ret, base, mix, keys) {\r\n    keys.map(function (k) {\r\n        ret.push({\r\n            title: k,\r\n            group: 'Operations',\r\n            render: [\r\n                base,\r\n                {\r\n                    tint: [1, .5, 1],\r\n                    operation: k,\r\n                    program: mix.program\r\n                }\r\n            ]\r\n        });\r\n    });\r\n}\r\n\r\nfunction addAlphas(ret, base, mix) {\r\n    [0, 0.25, 0.5, 0.75, 1].forEach(function (k) {\r\n        ret.push({\r\n            title: 'Alpha ' + k,\r\n            group: 'Alpha Blending',\r\n            render: [\r\n                base,\r\n                {\r\n                    tint: [1, .5, 1, k],\r\n                    operation: 'set',\r\n                    program: mix.program\r\n                }\r\n            ]\r\n        });\r\n    });\r\n}\r\n","export default function(min, max) {\n  min = min == null ? 0 : +min;\n  max = max == null ? 1 : +max;\n  if (arguments.length === 1) max = min, min = 0;\n  else max -= min;\n  return function() {\n    return Math.random() * max + min;\n  };\n}\n","export const colors = [\r\n    [0, .5, 1],\r\n    [0, 1, .5],\r\n    [0, 1, 1],\r\n    [.5, 0, 1],\r\n    [.5, 1, 0],\r\n    [1, 0, .5],\r\n    [1, 0, 1],\r\n    [1, .5, 0],\r\n    [1, 1, 0]\r\n];\r\n"],"names":["getRef","$ref","schema","parts","slice","split","x","forEach","part","traverse","current","root","c","r","result","Error","enum","Math","floor","randomUniform","length","type","parseFloat","minimum","Number","MIN_VALUE","maximum","MAX_VALUE","toPrecision","items","min","maxItems","minItems","i","item","value","push","anyOf","picked","properties","keys","prop","getRandom","getSchema","TG","Programs","Generators","render","program","s","definitions","operation","Object","texture","Filters","Mixers","addPrograms","n","l","k","o","params","p","q","t","pt","Array","isArray","val","isNaN","max","Type","BOOLEAN","COLOR_POINT","INTERPOLATION","NUMBER","INT","default","getProgram","tt","pr","filter","undefined","getFeatures","ret","baseId","tint","mixId","addGenerators","defs","color","colors","examples","e","addFilters","base","map","addMixers","mix","addOperations","addAlphas","arguments","random"],"mappings":"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"}