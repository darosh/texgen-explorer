{"version":3,"file":"texgen.js","sources":["operations/basic.js","operations/advanced.js","utils/mixColors.js","utils/wrap.js","utils/clamp.js","utils/distance.js","utils/smoothStep.js","programs/generators/noiseBase/hashRNG.js","programs/generators/celularNoiseBase/cellNoiseBase.js","utils/deg2rad.js","utils/bufferToCanvas.js","core/Buffer.js","core/Texture.js","core/Program.js","utils/ColorInterpolator.js","programs/generators/Number.js","programs/generators/SinX.js","programs/generators/SinY.js","programs/generators/Or.js","programs/generators/Xor.js","programs/generators/Rect.js","programs/generators/Circle.js","programs/generators/CheckerBoard.js","programs/generators/LinearGradient.js","programs/generators/RadialGradient.js","programs/generators/Noise.js","programs/generators/NoiseFractal.js","programs/generators/CellularNoise.js","programs/generators/CellularFractal.js","programs/generators/VoronoiNoise.js","programs/generators/VoronoiFractal.js","programs/generators/simplexNoiseBase/FastSimplexNoise.js","programs/generators/SimplexNoise.js","programs/filters/Abs.js","programs/filters/Copy.js","programs/filters/Convolution.js","programs/filters/Distort.js","programs/filters/GradientMap.js","programs/filters/Grayscale.js","programs/filters/Normalize.js","programs/filters/Pixelate.js","programs/filters/Posterize.js","programs/filters/SineDistort.js","programs/filters/Transform.js","programs/filters/Twirl.js","programs/mixers/PutTexture.js","programs/index.js","index.js"],"sourcesContent":["export function set(x, y) {\r\n    return y;\r\n}\r\n\r\nexport function add(x, y) {\r\n    return x + y;\r\n}\r\n\r\nexport function sub(x, y) {\r\n    return x - y;\r\n}\r\n\r\nexport function mul(x, y) {\r\n    return x * y;\r\n}\r\n\r\nexport function div(x, y) {\r\n    return x / y;\r\n}\r\n\r\nexport function and(x, y) {\r\n    return x & y;\r\n}\r\n\r\nexport function xor(x, y) {\r\n    return x ^ y;\r\n}\r\n\r\nexport function min(x, y) {\r\n    return Math.min(x, y);\r\n}\r\n\r\nexport function max(x, y) {\r\n    return Math.max(x, y);\r\n}\r\n","export function average(a, b) {\r\n    return (a + b) / 2;\r\n}\r\n\r\nexport function screen(a, b) {\r\n    return 1 - (1 - a) * (1 - b);\r\n}\r\n\r\nexport function overlay(a, b) {\r\n    return (b < .5)\r\n        ? (2 * a * b)\r\n        : (1 - 2 * (1 - a) * (1 - b));\r\n}\r\n\r\nexport function linearBurn(a, b) {\r\n    return a + b - 1;\r\n}\r\n\r\nexport function colorBurn(a, b) {\r\n    return (b === 0) ? b : (1 - (1 - a) / b);\r\n}\r\n\r\nexport function colorDodge(a, b) {\r\n    return (b >= 1) ? b : (a / (1 - b));\r\n}\r\n\r\nexport function difference(a, b) {\r\n    return Math.abs(a - b);\r\n}\r\n\r\nexport function exclusion(a, b) {\r\n    return .5 - 2 * (a - .5) * (b - .5);\r\n}\r\n\r\nexport function softLight(a, b) {\r\n    return (b < .5)\r\n        ? (2 * ((a / 2) + .25)) * b\r\n        : (1 - (2 * (1 - ((a / 2) + .25)) * (1 - b)));\r\n}\r\nexport function hardLight(a, b) {\r\n    return (a < .5)\r\n        ? (2 * b * a)\r\n        : (1 - 2 * (1 - b) * (1 - a));\r\n}\r\n\r\nexport function vividLight(a, b) {\r\n    return (a > .5)\r\n        ? (1 - (1 - b) / (2 * (a - .5)))\r\n        : (b / (1 - 2 * a));\r\n}\r\nexport function linearLight(a, b) {\r\n    return (b > 0.5)\r\n        ? (a + 2 * (b - .5))\r\n        : (a + 2 * b - 1);\r\n}\r\n\r\nexport function pinLight(a, b) {\r\n    return (b > 0.5)\r\n        ? Math.max(a, 2 * (b - .5))\r\n        : Math.min(a, 2 * b);\r\n}\r\n","export function mixColors(c1, c2, delta) {\r\n    return [\r\n        c1[0] * ( 1 - delta ) + c2[0] * delta,\r\n        c1[1] * ( 1 - delta ) + c2[1] * delta,\r\n        c1[2] * ( 1 - delta ) + c2[2] * delta\r\n        // c1[3] * ( 1 - delta ) + c2[3] * delta\r\n    ];\r\n}\r\n","export function wrap(value, min, max) {\r\n    const v = value - min;\r\n    const r = max - min;\r\n\r\n    return ( ( r + v % r ) % r ) + min;\r\n}\r\n\r\nexport function mirroredWrap(value, min, max) {\r\n    let v = value - min;\r\n    const r = ( max - min ) * 2;\r\n\r\n    v = ( r + v % r ) % r;\r\n\r\n    if (v > max - min) {\r\n        return ( r - v ) + min;\r\n    } else {\r\n        return v + min;\r\n    }\r\n}\r\n","export function clamp(value, min, max) {\r\n    return Math.min(Math.max(value, min), max);\r\n}\r\n","export function distance(x0, y0, x1, y1) {\r\n    const dx = x1 - x0, dy = y1 - y0;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n","import {clamp} from './clamp';\r\n\r\nexport function smoothStep(edge0, edge1, x) {\r\n    // Scale, bias and saturate x to 0..1 range\r\n    let xx = clamp(( x - edge0 ) / ( edge1 - edge0 ), 0, 1);\r\n\r\n    // Evaluate polynomial\r\n    return xx * xx * ( 3 - 2 * xx );\r\n}\r\n","export function hashRNG(seed, x, y) {\r\n    const s = ( Math.abs(seed % 2147483648) === 0 ) ? 1 : seed;\r\n    let a = ( ( s * ( x + 1 ) * 777 ) ^ ( s * ( y + 1 ) * 123 ) ) % 2147483647;\r\n\r\n    a = (a ^ 61) ^ (a >> 16);\r\n    a = a + (a << 3);\r\n    a = a ^ (a >> 4);\r\n    a = a * 0x27d4eb2d;\r\n    a = a ^ (a >> 15);\r\n    a = a / 2147483647;\r\n\r\n    return a;\r\n}\r\n","import {hashRNG} from '../noiseBase/hashRNG';\r\n\r\nexport function cellNoiseBase(x, y, seed, density, weight) {\r\n    let qx, qy, rx, ry, w, px, py, dx, dy;\r\n    let dist, value;\r\n    let shortest = Infinity;\r\n    density = Math.abs(density);\r\n\r\n    for (let sx = -2; sx <= 2; sx++) {\r\n        for (let sy = -2; sy <= 2; sy++) {\r\n            qx = Math.ceil(x / density) + sx;\r\n            qy = Math.ceil(y / density) + sy;\r\n\r\n            rx = hashRNG(seed, qx, qy);\r\n            ry = hashRNG(seed * 2, qx, qy);\r\n            w = ( weight > 0 ) ? 1 + hashRNG(seed * 3, qx, qy) * weight : 1;\r\n\r\n            px = ( rx + qx ) * density;\r\n            py = ( ry + qy ) * density;\r\n\r\n            dx = Math.abs(px - x);\r\n            dy = Math.abs(py - y);\r\n\r\n            dist = ( dx * dx + dy * dy ) * w;\r\n\r\n            if (dist < shortest) {\r\n                shortest = dist;\r\n                value = rx;\r\n            }\r\n        }\r\n    }\r\n\r\n    return {dist: Math.sqrt(shortest), value: value};\r\n}\r\n","const dr = Math.PI / 180;\r\n\r\nexport function deg2rad(deg) {\r\n    return deg * dr;\r\n}\r\n","export function bufferToCanvas(buffer, width, height, canvas = null) {\r\n    const can = canvas || document.createElement('canvas');\r\n    can.width = width;\r\n    can.height = height;\r\n    const ctx = can.getContext('2d');\r\n    const imageData = ctx.getImageData(0, 0, width, height);\r\n    const data = imageData.data;\r\n    const heap = new Uint8Array(buffer);\r\n    const last = heap.length;\r\n    let i = 0;\r\n\r\n    while (i < last) {\r\n        data[i] = heap[i++];\r\n    }\r\n\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    return can;\r\n}\r\n","export class Buffer {\r\n    constructor(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.array = new Float32Array(width * height * 4);\r\n        this.color = new Float32Array(4);\r\n    }\r\n\r\n    copy(buffer) {\r\n        this.array.set(buffer.array);\r\n    }\r\n\r\n    getPixelNearest(x, y) {\r\n        let _x = Math.round(x);\r\n        let _y = Math.round(y);\r\n\r\n        while (_y >= this.height) _y -= this.height;\r\n        while (_y < 0) _y += this.height;\r\n        while (_x >= this.width) _x -= this.width;\r\n        while (_x < 0) _x += this.width;\r\n\r\n        const array = this.array;\r\n        const color = this.color;\r\n        const offset = _y * this.width * 4 + _x * 4;\r\n\r\n        color[0] = array[offset];\r\n        color[1] = array[offset + 1];\r\n        color[2] = array[offset + 2];\r\n\r\n        return this.color;\r\n    }\r\n\r\n    getPixelBilinear(x, y) {\r\n        const px = Math.floor(x);\r\n        const py = Math.floor(y);\r\n        const p0 = px + py * this.width;\r\n\r\n        const array = this.array;\r\n        const color = this.color;\r\n\r\n        // Calculate the weights for each pixel\r\n        const fx = x - px;\r\n        const fy = y - py;\r\n        const fx1 = 1 - fx;\r\n        const fy1 = 1 - fy;\r\n\r\n        const w1 = fx1 * fy1;\r\n        const w2 = fx * fy1;\r\n        const w3 = fx1 * fy;\r\n        const w4 = fx * fy;\r\n\r\n        let p1 = p0 * 4; \t\t\t\t\t\t\t// 0 + 0 * w\r\n        let p2 = ( 1 + p0 ) * 4; \t\t\t\t\t// 1 + 0 * w\r\n        let p3 = ( 1 * this.width + p0 ) * 4; \t\t// 0 + 1 * w\r\n        let p4 = ( 1 + 1 * this.width + p0 ) * 4; \t// 1 + 1 * w\r\n\r\n        const len = this.width * this.height * 4;\r\n\r\n        if (p1 >= len) p1 -= len;\r\n        if (p1 < 0) p1 += len;\r\n        if (p2 >= len) p2 -= len;\r\n        if (p2 < 0) p2 += len;\r\n        if (p3 >= len) p3 -= len;\r\n        if (p3 < 0) p3 += len;\r\n        if (p4 >= len) p4 -= len;\r\n        if (p4 < 0) p4 += len;\r\n\r\n        // Calculate the weighted sum of pixels (for each color channel)\r\n        color[0] = array[p1] * w1 + array[p2] * w2 + array[p3] * w3 + array[p4] * w4;\r\n        color[1] = array[p1 + 1] * w1 + array[p2 + 1] * w2 + array[p3 + 1] * w3 + array[p4 + 1] * w4;\r\n        color[2] = array[p1 + 2] * w1 + array[p2 + 2] * w2 + array[p3 + 2] * w3 + array[p4 + 2] * w4;\r\n        color[3] = array[p1 + 3] * w1 + array[p2 + 3] * w2 + array[p3 + 3] * w3 + array[p4 + 3] * w4;\r\n\r\n        return this.color;\r\n    }\r\n\r\n    getPixelOffset(offset) {\r\n        const array = this.array;\r\n        const color = this.color;\r\n\r\n        offset = parseInt(offset * 4);\r\n\r\n        color[0] = array[offset];\r\n        color[1] = array[offset + 1];\r\n        color[2] = array[offset + 2];\r\n        color[3] = array[offset + 3];\r\n\r\n        return this.color;\r\n    }\r\n}\r\n","import {Buffer} from './Buffer';\r\nimport {set} from '../operations/basic';\r\n\r\nexport class Texture {\r\n    constructor(width, height) {\r\n        this.color = new Float32Array(4);\r\n        this.buffer = new Buffer(width, height);\r\n        this.bufferCopy = new Buffer(width, height);\r\n    }\r\n\r\n    toImageData(context) {\r\n        const buffer = this.buffer;\r\n        const array = buffer.array;\r\n\r\n        const imageData = context.createImageData(buffer.width, buffer.height);\r\n        const data = imageData.data;\r\n\r\n        let i;\r\n        const il = array.length;\r\n\r\n        for (i = 0; i < il; i += 4) {\r\n            data[i] = array[i] * 255;\r\n            data[i + 1] = array[i + 1] * 255;\r\n            data[i + 2] = array[i + 2] * 255;\r\n            data[i + 3] = 255;\r\n        }\r\n\r\n        return imageData;\r\n    }\r\n\r\n    toCanvas(canvas) {\r\n        if (canvas === undefined) {\r\n            canvas = document.createElement('canvas');\r\n        }\r\n\r\n        canvas.width = this.buffer.width;\r\n        canvas.height = this.buffer.height;\r\n\r\n        const context = canvas.getContext('2d');\r\n        const imageData = this.toImageData(context);\r\n\r\n        context.putImageData(imageData, 0, 0);\r\n\r\n        return canvas;\r\n    }\r\n\r\n    set(program, operation) {\r\n        this.bufferCopy.copy(this.buffer);\r\n\r\n        const op = operation === undefined ? set : operation;\r\n        const dst = this.buffer;\r\n        const src = this.bufferCopy;\r\n        const color = this.color;\r\n        const tint = program.tint();\r\n\r\n        const array = dst.array;\r\n        const width = dst.width;\r\n        const height = dst.height;\r\n        const il = array.length;\r\n\r\n        let a = 1 - tint[3];\r\n        let b = tint[3];\r\n        let x = 0;\r\n        let y = 0;\r\n        let i;\r\n\r\n        if (tint[3] === 1) {\r\n            for (i = 0; i < il;) {\r\n                program.run(color, x, y, src, width, height);\r\n                array[i] = op(array[i++], color[0] * tint[0]);\r\n                array[i] = op(array[i++], color[1] * tint[1]);\r\n                array[i] = op(array[i++], color[2] * tint[2]);\r\n                i++;\r\n\r\n                if (++x === width) {\r\n                    x = 0;\r\n                    y++;\r\n                }\r\n            }\r\n        } else if (tint[3] !== 0) {\r\n            for (i = 0; i < il;) {\r\n                program.run(color, x, y, src, width, height);\r\n                array[i] = array[i] * a + op(array[i++], color[0] * tint[0]) * b;\r\n                array[i] = array[i] * a + op(array[i++], color[1] * tint[1]) * b;\r\n                array[i] = array[i] * a + op(array[i++], color[2] * tint[2]) * b;\r\n                i++;\r\n\r\n                if (++x === width) {\r\n                    x = 0;\r\n                    y++;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return this;\r\n    }\r\n\r\n    toArrayBuffer() {\r\n        const array = this.buffer.array;\r\n        const il = array.length;\r\n        const buffer = new ArrayBuffer(il);\r\n        const res = new Uint8ClampedArray(buffer);\r\n        let i;\r\n\r\n        for (i = 0; i < il; i += 4) {\r\n            res[i] = array[i] * 255;\r\n            res[i + 1] = array[i + 1] * 255;\r\n            res[i + 2] = array[i + 2] * 255;\r\n            res[i + 3] = 255;\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    static isSingleColor(buffer) {\r\n        const a = new Uint8ClampedArray(buffer);\r\n        const l = a.length;\r\n        let i = 4;\r\n\r\n        while (i < l) {\r\n            if (a[0] !== a[i++] || a[1] !== a[i++] || a[2] !== a[i++]) {\r\n                return false;\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nimport * as operations from '../operations/index';\r\n\r\nfor (let o in operations) {\r\n    if (!Texture.prototype[o]) {\r\n        Texture.prototype[o] = function (program) {\r\n            return this.set(program, operations[o]);\r\n        };\r\n    }\r\n}\r\n","export class Program {\r\n    constructor(proto) {\r\n        // this._tint = new Float32Array([1, 1, 1, 1]);\r\n        this._tint = {\r\n            0: 1, 1: 1, 2: 1, 3: 1, set: function (a) {\r\n                this._tint[0] = a[0];\r\n                this._tint[1] = a[1];\r\n                this._tint[2] = a[2];\r\n                this._tint[3] = a[3];\r\n            }\r\n        };\r\n\r\n        if (proto && proto.params) {\r\n            Object.keys(proto.params).forEach((p) => {\r\n                const v = proto.params[p].val;\r\n\r\n                if (v !== null) {\r\n                    if (Array.isArray(v)) {\r\n                        this[p].apply(this, v);\r\n                    } else {\r\n                        this[p].call(this, v);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    tint(r, g, b, a) {\r\n        if (arguments.length) {\r\n            this._tint[0] = r;\r\n            this._tint[1] = g;\r\n            this._tint[2] = b;\r\n            this._tint[3] = arguments.length > 3 ? a : this._tint[3];\r\n            return this;\r\n        } else {\r\n            return this._tint;\r\n        }\r\n    }\r\n}\r\n\r\nexport const Type = {\r\n    NUMBER: 0,\r\n    INT: 1,\r\n    BOOLEAN: 2,\r\n    INTERPOLATION: 3,\r\n    COLOR_POINT: 4,\r\n    COLOR: 5,\r\n    TEXTURE: 6,\r\n    0: 'NUMBER',\r\n    1: 'INT',\r\n    2: 'BOOLEAN',\r\n    3: 'INTERPOLATION',\r\n    4: 'COLOR_POINT',\r\n    5: 'COLOR',\r\n    6: 'TEXTURE'\r\n};\r\n\r\nexport const EPSILON = Number.EPSILON;\r\n","import {mixColors} from './mixColors';\r\nimport {mirroredWrap, wrap} from './wrap';\r\nimport {clamp} from './clamp';\r\n\r\nexport const ColorInterpolatorMethod = {\r\n    STEP: 0,\r\n    LINEAR: 1,\r\n    SPLINE: 2\r\n};\r\n\r\nexport class ColorInterpolator {\r\n    constructor(method) {\r\n        this.points = [];\r\n        this.low = 0;\r\n        this.high = 0;\r\n        this.interpolation = ( typeof( method ) === 'undefined' ) ? ColorInterpolatorMethod.LINEAR : method;\r\n        this.repeat = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    set(points) {\r\n        this.points = points;\r\n        this.points.sort(function (a, b) {\r\n            return a.pos - b.pos;\r\n        });\r\n\r\n        this.low = this.points[0].pos;\r\n        this.high = this.points[this.points.length - 1].pos;\r\n\r\n        return this;\r\n    }\r\n\r\n    addPoint(position, color) {\r\n\r\n        this.points.push({pos: position, color: color});\r\n        this.points.sort(function (a, b) {\r\n            return a.pos - b.pos;\r\n        });\r\n\r\n        this.low = this.points[0].pos;\r\n        this.high = this.points[this.points.length - 1].pos;\r\n\r\n        return this;\r\n    }\r\n\r\n    setRepeat(value) {\r\n        this.repeat = value;\r\n        return this;\r\n    }\r\n\r\n    setInterpolation(value) {\r\n        this.interpolation = value;\r\n        return this;\r\n    }\r\n\r\n    getColorAt(pos) {\r\n        if (!this.points.length) {\r\n            return [0, 0, 0];\r\n        } else if (this.repeat === 2) {\r\n            pos = mirroredWrap(pos, this.low, this.high);\r\n        }\r\n        else if (this.repeat) {\r\n            pos = wrap(pos, this.low, this.high);\r\n        }\r\n        else {\r\n            pos = clamp(pos, this.low, this.high);\r\n        }\r\n\r\n        let i = 0;\r\n        const points = this.points;\r\n\r\n        while (points[i + 1].pos < pos) i++;\r\n\r\n        const p1 = points[i];\r\n        const p2 = points[i + 1];\r\n\r\n        const delta = ( pos - p1.pos ) / ( p2.pos - p1.pos );\r\n\r\n        if (this.interpolation === ColorInterpolatorMethod.STEP) {\r\n            return p1.color;\r\n        } else if (this.interpolation === ColorInterpolatorMethod.LINEAR) {\r\n            return mixColors(p1.color, p2.color, delta);\r\n        } else if (this.interpolation === ColorInterpolatorMethod.SPLINE) {\r\n            const ar = 2 * p1.color[0] - 2 * p2.color[0];\r\n            const br = -3 * p1.color[0] + 3 * p2.color[0];\r\n            const dr = p1.color[0];\r\n\r\n            const ag = 2 * p1.color[1] - 2 * p2.color[1];\r\n            const bg = -3 * p1.color[1] + 3 * p2.color[1];\r\n            const dg = p1.color[1];\r\n\r\n            const ab = 2 * p1.color[2] - 2 * p2.color[2];\r\n            const bb = -3 * p1.color[2] + 3 * p2.color[2];\r\n            const db = p1.color[2];\r\n\r\n            const delta2 = delta * delta;\r\n            const delta3 = delta2 * delta;\r\n\r\n            return [\r\n                ar * delta3 + br * delta2 + dr,\r\n                ag * delta3 + bg * delta2 + dg,\r\n                ab * delta3 + bb * delta2 + db\r\n            ];\r\n        }\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Number extends Program {\r\n    run(color) {\r\n        color[0] = 1;\r\n        color[1] = 1;\r\n        color[2] = 1;\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class SinX extends Program {\r\n    constructor() {\r\n        super(SinX);\r\n    }\r\n\r\n    size(value) {\r\n        this._size = Math.max(Number.EPSILON, value) / Math.PI / 2;\r\n        return this;\r\n    }\r\n\r\n    offset(value) {\r\n        this._offset = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x) {\r\n        const value = Math.sin(( x + this._offset ) / this._size);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 16,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: 64,\r\n                offset: 16\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class SinY extends Program {\r\n    constructor() {\r\n        super(SinY);\r\n    }\r\n\r\n    size(value) {\r\n        this._size = Math.max(Number.EPSILON, value) / Math.PI / 2;\r\n        return this;\r\n    }\r\n\r\n    offset(value) {\r\n        this._offset = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = Math.sin(( y + this._offset ) / this._size);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 16,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Or extends Program {\r\n    constructor() {\r\n        super(Program);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [Math.max(Number.EPSILON, x), Math.max(Number.EPSILON, y)];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( (256 * x / this._size[0]) | (256 * y / this._size[1]) ) % 256 / 255;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [256, 256],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [64, 64]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Xor extends Program {\r\n    constructor() {\r\n        super(Xor);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [Math.max(Number.EPSILON, x), Math.max(Number.EPSILON, y)];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( 256 * x / this._size[0] ^ 256 * y / this._size[1] ) % 256 / 255;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [256, 256],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [128, 64]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Rect extends Program {\r\n    constructor() {\r\n        super(Rect);\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( x >= this._offset[0] && x <= ( this._offset[0] + this._size[0] ) && y <= ( this._offset[1] + this._size[1] ) && y >= this._offset[1] ) ? 1 : 0;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            size: {\r\n                val: [128, 64],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                offset: [(256 - 128) / 2, (256 - 64) / 2],\r\n                size: [128, 64]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\nimport {distance} from '../../utils/distance';\r\nimport {smoothStep} from '../../utils/smoothStep';\r\n\r\nexport class Circle extends Program {\r\n    constructor() {\r\n        super(Circle);\r\n    }\r\n\r\n    weight(value) {\r\n        this._delta = value;\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    size(value) {\r\n        this._size = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const dist = distance(x, y, this._offset[0], this._offset[1]);\r\n        const value = 1 - smoothStep(this._size - this._delta, this._size, dist);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            size: {\r\n                val: 128,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            weight: {\r\n                val: 1,\r\n                min: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                offset: [128, 128],\r\n                size: 128,\r\n                weight: 32\r\n            },\r\n            {\r\n                offset: [128, 128],\r\n                size: 128,\r\n                weight: 128\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class CheckerBoard extends Program {\r\n    constructor() {\r\n        super(CheckerBoard);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [x, y];\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    shift(value) {\r\n        this._shift = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = ( ( ( y + this._offset[1] ) / this._size[1] ) & 1 ) ^ ( ( ( x + this._offset[0] + parseInt(y / this._size[1]) * this._shift ) / this._size[0] ) & 1 ) ? 0 : 1;\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [32, 32],\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            shift: {\r\n                val: 0,\r\n                scale: true\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [16, 16],\r\n                offset: [8, 8],\r\n                shift: 0\r\n            },\r\n            {\r\n                size: [64, 16],\r\n                offset: [0, 0],\r\n                shift: 8\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\n\r\nexport class LinearGradient extends Program {\r\n    constructor() {\r\n        super(LinearGradient);\r\n    }\r\n\r\n    size(value) {\r\n        this._size = Math.max(LinearGradient.params.size.min, value);\r\n        return this;\r\n    }\r\n\r\n    repeat(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setRepeat(value);\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    point(position, color) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.addPoint(position, color);\r\n        return this;\r\n    }\r\n\r\n    run(color, x) {\r\n        color.set(this._gradient.getColorAt(x / this._size));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 256,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            repeat: {\r\n                val: true,\r\n                type: Type.BOOLEAN\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            },\r\n            point: {\r\n                val: null,\r\n                type: Type.COLOR_POINT\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                interpolation: ColorInterpolatorMethod.STEP\r\n            },\r\n            {\r\n                interpolation: ColorInterpolatorMethod.SPLINE,\r\n                size: 128\r\n            },\r\n            {\r\n                interpolation: ColorInterpolatorMethod.SPLINE,\r\n                repeat: false,\r\n                size: 32\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\nimport {distance} from '../../utils/distance';\r\n\r\nexport class RadialGradient extends Program {\r\n    constructor() {\r\n        super(RadialGradient);\r\n    }\r\n\r\n    repeat(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setRepeat(value);\r\n        return this;\r\n    }\r\n\r\n    size(value) {\r\n        this._size = value;\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    point(position, color) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.addPoint(position, color);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const dist = distance(x, y, this._offset[0], this._offset[1]);\r\n        color.set(this._gradient.getColorAt(dist / this._size));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: 128,\r\n                min: Number.EPSILON,\r\n                scale: true\r\n            },\r\n            offset: {\r\n                val: [0, 0],\r\n                scale: true\r\n            },\r\n            repeat: {\r\n                val: true,\r\n                type: Type.BOOLEAN\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            },\r\n            point: {\r\n                val: null,\r\n                type: Type.COLOR_POINT\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: 64,\r\n                offset: [128, 128],\r\n                repeat: false\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {hashRNG} from './noiseBase/hashRNG';\r\n\r\nexport class Noise extends Program {\r\n    constructor() {\r\n        super(Noise);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const value = hashRNG(this._seed, x, y);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\nimport {hashRNG} from './noiseBase/hashRNG';\r\n\r\nexport class NoiseFractal extends Program {\r\n    constructor() {\r\n        super(NoiseFractal);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._baseFrequency = 1 / value;\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._interpolator = this._interpolator || new ColorInterpolator();\r\n        this._interpolator.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        let value = 0;\r\n        let amp = this._amplitude;\r\n        let freq = this._baseFrequency;\r\n        let x1, y1, dx, dy;\r\n        let v1, v2, v3, v4;\r\n        let i1, i2;\r\n\r\n        for (let j = 1; j <= this._octaves; j++) {\r\n            x1 = Math.floor(x * freq);\r\n            y1 = Math.floor(y * freq);\r\n\r\n            if (this._interpolator.interpolation === ColorInterpolatorMethod.STEP) {\r\n                value += hashRNG(this._seed * j, x1, y1) * amp;\r\n            } else {\r\n                dx = ( x * freq ) - x1;\r\n                dy = ( y * freq ) - y1;\r\n\r\n                v1 = hashRNG(this._seed * j, x1, y1);\r\n                v2 = hashRNG(this._seed * j, x1 + 1, y1);\r\n                v3 = hashRNG(this._seed * j, x1, y1 + 1);\r\n                v4 = hashRNG(this._seed * j, x1 + 1, y1 + 1);\r\n\r\n                this._interpolator.set([\r\n                    {pos: 0, color: [v1]},\r\n                    {pos: 1, color: [v2]}\r\n                ]);\r\n\r\n                i1 = this._interpolator.getColorAt(dx);\r\n\r\n                this._interpolator.set([\r\n                    {pos: 0, color: [v3]},\r\n                    {pos: 1, color: [v4]}\r\n                ]);\r\n\r\n                i2 = this._interpolator.getColorAt(dx);\r\n\r\n                this._interpolator.set([\r\n                    {pos: 0, color: [i1[0]]},\r\n                    {pos: 1, color: [i2[0]]}\r\n                ]);\r\n\r\n                value += this._interpolator.getColorAt(dy)[0] * amp;\r\n            }\r\n\r\n            freq *= this._step;\r\n            amp *= this._persistence;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 16,\r\n                min: 0\r\n            },\r\n            amplitude: {\r\n                val: 0.5,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.75,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 3,\r\n                min: 1,\r\n                max: 8\r\n            },\r\n            step: {\r\n                min: 1,\r\n                val: 4,\r\n                max: 16\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                amplitude: 1,\r\n                persistence: 0,\r\n                octaves: 1,\r\n                step: 4,\r\n                interpolation: 2\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 8,\r\n                amplitude: 1,\r\n                persistence: 1,\r\n                octaves: 1,\r\n                step: 4,\r\n                interpolation: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                amplitude: 1,\r\n                persistence: 1,\r\n                octaves: 1,\r\n                step: 4,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                amplitude: 1,\r\n                persistence: 1,\r\n                octaves: 2,\r\n                step: 2,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                amplitude: 0.25,\r\n                persistence: 0.75,\r\n                octaves: 4,\r\n                step: 2,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                amplitude: 0.25,\r\n                persistence: 0.75,\r\n                octaves: 4,\r\n                step: 2,\r\n                interpolation: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 3,\r\n                step: 4,\r\n                interpolation: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 3,\r\n                step: 4,\r\n                interpolation: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class CellularNoise extends Program {\r\n    constructor() {\r\n        super(CellularNoise);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const p = cellNoiseBase(x, y, this._seed, this._density, this._weight);\r\n\r\n        let value = 1 - ( p.dist / this._density );\r\n\r\n        if (this._density < 0) {\r\n            value -= 1;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 32,\r\n                min: 0\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: 0\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 16\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 32\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class CellularFractal extends Program {\r\n    constructor() {\r\n        super(CellularFractal);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    scale(value) {\r\n        this._scale = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        let p;\r\n        let value = 0;\r\n        let amp = this._amplitude;\r\n        let dens = this._density;\r\n\r\n        for (let j = 1; j <= this._octaves; j++) {\r\n            p = cellNoiseBase(x * this._scale, y * this._scale, this._seed * j, dens, this._weight);\r\n\r\n            p.dist = 1 - ( p.dist / dens );\r\n            if (dens < 0) p.dist -= 1;\r\n\r\n            value += p.dist * amp;\r\n            dens /= this._step;\r\n            amp *= this._persistence;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 64,\r\n                min: 0\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            amplitude: {\r\n                val: 0.5,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: 0,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 4,\r\n                min: 1,\r\n                max: 8\r\n            },\r\n            step: {\r\n                val: 2,\r\n                min: 1,\r\n                max: 16\r\n            },\r\n            scale: {\r\n                val: 1,\r\n                scale: false\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 4,\r\n                step: 2\r\n            }, {\r\n                seed: 1,\r\n                density: 32,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 2,\r\n                step: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class VoronoiNoise extends Program {\r\n    constructor() {\r\n        super(VoronoiNoise);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        const p = cellNoiseBase(x, y, this._seed, this._density, this._weight);\r\n\r\n        color[0] = p.value;\r\n        color[1] = p.value;\r\n        color[2] = p.value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 32,\r\n                min: EPSILON\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: 0\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 16\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 0\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 1\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 16,\r\n                weight: 128\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport {cellNoiseBase} from './celularNoiseBase/cellNoiseBase';\r\n\r\nexport class VoronoiFractal extends Program {\r\n    constructor() {\r\n        super(VoronoiFractal);\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = Math.max(0, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        let p;\r\n        let value = 0;\r\n        let amp = this._amplitude;\r\n        let dens = this._density;\r\n\r\n        for (let j = 1; j <= this._octaves; j++) {\r\n            p = cellNoiseBase(x, y, this._seed * j, dens, this._weight);\r\n\r\n            value += p.value * amp;\r\n            dens /= this._step;\r\n            amp *= this._persistence;\r\n        }\r\n\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 64,\r\n                min: EPSILON\r\n            },\r\n            weight: {\r\n                val: 0,\r\n                min: EPSILON,\r\n                max: 2\r\n            },\r\n            amplitude: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 4,\r\n                min: 1,\r\n                max: 8\r\n            },\r\n            step: {\r\n                val: 2,\r\n                min: 1,\r\n                max: 16\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 64,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 4,\r\n                step: 2\r\n            }, {\r\n                seed: 1,\r\n                density: 32,\r\n                weight: 2,\r\n                amplitude: 0.5,\r\n                persistence: 0.5,\r\n                octaves: 2,\r\n                step: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","/*\r\n * A speed-improved simplex noise algorithm for 2D, 3D and 4D in JavaScript.\r\n *\r\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\r\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\r\n * Better rank ordering method by Stefan Gustavson in 2012.\r\n *\r\n * This code was placed in the public domain by its original author,\r\n * Stefan Gustavson. You may use it as you see fit, but\r\n * attribution is appreciated.\r\n */\r\nexport default class FastSimplexNoise {\r\n    constructor(options = {}) {\r\n        if (options.hasOwnProperty('amplitude')) {\r\n            this.amplitude = options.amplitude;\r\n        }\r\n        else\r\n            this.amplitude = 1.0;\r\n        if (options.hasOwnProperty('frequency')) {\r\n            this.frequency = options.frequency;\r\n        }\r\n        else\r\n            this.frequency = 1.0;\r\n        if (options.hasOwnProperty('octaves')) {\r\n            this.octaves = options.octaves;\r\n        }\r\n        else\r\n            this.octaves = 1;\r\n        if (options.hasOwnProperty('persistence')) {\r\n            this.persistence = options.persistence;\r\n        }\r\n        else\r\n            this.persistence = 0.5;\r\n        if (options.hasOwnProperty('random')) {\r\n            this.random = options.random;\r\n        }\r\n        else\r\n            this.random = Math.random;\r\n        let min;\r\n        if (options.hasOwnProperty('min')) {\r\n            min = options.min;\r\n        }\r\n        else\r\n            min = -1;\r\n        let max;\r\n        if (options.hasOwnProperty('max')) {\r\n            max = options.max;\r\n        }\r\n        else\r\n            max = 1;\r\n        this.scale = min === -1 && max === 1\r\n            ? value => value\r\n            : value => min + ((value + 1) / 2) * (max - min);\r\n        const p = new Uint8Array(256);\r\n        for (let i = 0; i < 256; i++)\r\n            p[i] = i;\r\n        let n;\r\n        let q;\r\n        for (let i = 255; i > 0; i--) {\r\n            n = Math.floor((i + 1) * this.random());\r\n            q = p[i];\r\n            p[i] = p[n];\r\n            p[n] = q;\r\n        }\r\n        this.perm = new Uint8Array(512);\r\n        this.permMod12 = new Uint8Array(512);\r\n        for (let i = 0; i < 512; i++) {\r\n            this.perm[i] = p[i & 255];\r\n            this.permMod12[i] = this.perm[i] % 12;\r\n        }\r\n    }\r\n\r\n    dot(gs, coords) {\r\n        return gs\r\n            .slice(0, Math.min(gs.length, coords.length))\r\n            .reduce((total, g, i) => total + (g * coords[i]), 0);\r\n    }\r\n\r\n    raw2D(x, y) {\r\n        // Skew the input space to determine which simplex cell we're in\r\n        const s = (x + y) * 0.5 * (Math.sqrt(3.0) - 1.0); // Hairy factor for 2D\r\n        const i = Math.floor(x + s);\r\n        const j = Math.floor(y + s);\r\n        const t = (i + j) * FastSimplexNoise.G2;\r\n        const X0 = i - t; // Unskew the cell origin back to (x,y) space\r\n        const Y0 = j - t;\r\n        const x0 = x - X0; // The x,y distances from the cell origin\r\n        const y0 = y - Y0;\r\n        // Determine which simplex we are in.\r\n        const i1 = x0 > y0 ? 1 : 0;\r\n        const j1 = x0 > y0 ? 0 : 1;\r\n        // Offsets for corners\r\n        const x1 = x0 - i1 + FastSimplexNoise.G2;\r\n        const y1 = y0 - j1 + FastSimplexNoise.G2;\r\n        const x2 = x0 - 1.0 + 2.0 * FastSimplexNoise.G2;\r\n        const y2 = y0 - 1.0 + 2.0 * FastSimplexNoise.G2;\r\n        // Work out the hashed gradient indices of the three simplex corners\r\n        const ii = i & 255;\r\n        const jj = j & 255;\r\n        const gi0 = this.permMod12[ii + this.perm[jj]];\r\n        const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];\r\n        const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];\r\n        // Calculate the contribution from the three corners\r\n        const t0 = 0.5 - x0 * x0 - y0 * y0;\r\n        const n0 = t0 < 0 ? 0.0 : Math.pow(t0, 4) * this.dot(FastSimplexNoise.GRAD3D[gi0], [x0, y0]);\r\n        const t1 = 0.5 - x1 * x1 - y1 * y1;\r\n        const n1 = t1 < 0 ? 0.0 : Math.pow(t1, 4) * this.dot(FastSimplexNoise.GRAD3D[gi1], [x1, y1]);\r\n        const t2 = 0.5 - x2 * x2 - y2 * y2;\r\n        const n2 = t2 < 0 ? 0.0 : Math.pow(t2, 4) * this.dot(FastSimplexNoise.GRAD3D[gi2], [x2, y2]);\r\n        // Add contributions from each corner to get the final noise value.\r\n        // The result is scaled to return values in the interval [-1, 1]\r\n        return 70.14805770653952 * (n0 + n1 + n2);\r\n    }\r\n\r\n    scaled2D(x, y) {\r\n        let amplitude = this.amplitude;\r\n        let frequency = this.frequency;\r\n        let maxAmplitude = 0;\r\n        let noise = 0;\r\n        for (let i = 0; i < this.octaves; i++) {\r\n            noise += this.raw2D(x * frequency, y * frequency) * amplitude;\r\n            maxAmplitude += amplitude;\r\n            amplitude *= this.persistence;\r\n            frequency *= 2;\r\n        }\r\n        return this.scale(noise / maxAmplitude);\r\n    }\r\n}\r\nFastSimplexNoise.G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\r\nFastSimplexNoise.GRAD3D = [\r\n    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],\r\n    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],\r\n    [0, 1, 1], [0, -1, -1], [0, 1, -1], [0, -1, -1]\r\n];\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport FastSimplexNoise from './simplexNoiseBase/FastSimplexNoise';\r\nimport {hashRNG} from './noiseBase/hashRNG';\r\n\r\nexport class SimplexNoise extends Program {\r\n    constructor() {\r\n        super(SimplexNoise);\r\n        this._count = 0;\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y) {\r\n        this._base = this._base || new FastSimplexNoise({\r\n                min: 0,\r\n                max: 1,\r\n                frequency: 1 / this._density,\r\n                octaves: this._octaves,\r\n                amplitude: this._amplitude,\r\n                persistence: this._persistence,\r\n                random: function () {\r\n                    return hashRNG(this._seed, this._count++, 0);\r\n                }\r\n            });\r\n\r\n        const value = this._base.scaled2D(x, y);\r\n        color[0] = value;\r\n        color[1] = value;\r\n        color[2] = value;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 16,\r\n                min: EPSILON\r\n            },\r\n            amplitude: {\r\n                val: 1,\r\n                min: EPSILON,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 1,\r\n                min: 1,\r\n                max: 8\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 128,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 8\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 128,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 5\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 12,\r\n                amplitude: 0.25,\r\n                persistence: 1,\r\n                octaves: 2\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Abs extends Program {\r\n    run(color, x, y, src) {\r\n        const value = src.getPixelNearest(x, y);\r\n        color[0] = Math.abs(value[0]);\r\n        color[1] = Math.abs(value[1]);\r\n        color[2] = Math.abs(value[2]);\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Copy extends Program {\r\n    run(color, x, y, src) {\r\n        const value = src.getPixelNearest(x, y);\r\n        color.set(value);\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {clamp} from \"../../utils/clamp\";\r\n\r\nexport class Convolution extends Program {\r\n    constructor() {\r\n        super(Convolution);\r\n    }\r\n\r\n    preset(value) {\r\n        this._weights = Convolution.Presets[value] || Convolution.Presets[0];\r\n        this._side = Math.round(Math.sqrt(this._weights.length));\r\n        this._halfSide = Math.floor(this._side / 2);\r\n        return this;\r\n    }\r\n\r\n    static get Presets() {\r\n        return {\r\n            0: [0, -1, 0,\r\n                -1, 5, -1,\r\n                0, -1, 0],\r\n            1: [1 / 9, 1 / 9, 1 / 9,\r\n                1 / 9, 1 / 9, 1 / 9,\r\n                1 / 9, 1 / 9, 1 / 9],\r\n            2: [1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25,\r\n                1 / 25, 1 / 25, 1 / 25, 1 / 25, 1 / 25],\r\n            3: [2, 1, 0,\r\n                1, 1, -1,\r\n                0, -1, -2],\r\n            4: [0, 1, 0,\r\n                1, -4, 1,\r\n                0, 1, 0]\r\n        };\r\n    }\r\n\r\n    run(color, x, y, src, width, height) {\r\n        const sy = y;\r\n        const sx = x;\r\n        let r = 0, g = 0, b = 0;\r\n\r\n        for (let cy = 0; cy < this._side; cy++) {\r\n            for (let cx = 0; cx < this._side; cx++) {\r\n                const scy = sy + cy - this._halfSide;\r\n                const scx = sx + cx - this._halfSide;\r\n                const wt = this._weights[cy * this._side + cx];\r\n                const value = src.getPixelNearest(clamp(scx, 0, width - 1), clamp(scy, 0, height - 1));\r\n                r += value[0] * wt;\r\n                g += value[1] * wt;\r\n                b += value[2] * wt;\r\n            }\r\n        }\r\n\r\n        color[0] = r;\r\n        color[1] = g;\r\n        color[2] = b;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            preset: {\r\n                val: 0,\r\n                min: 0,\r\n                max: 4,\r\n                type: Type.INT\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                preset: 1\r\n            },\r\n            {\r\n                preset: 2\r\n            },\r\n            {\r\n                preset: 3\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {EPSILON, Program, Type} from '../../core/Program';\r\nimport FastSimplexNoise from \"../generators/simplexNoiseBase/FastSimplexNoise\";\r\nimport {hashRNG} from \"../generators/noiseBase/hashRNG\";\r\n\r\nexport class Distort extends Program {\r\n    constructor() {\r\n        super(Distort);\r\n        this._count = 0;\r\n    }\r\n\r\n    seed(value) {\r\n        this._seed = value;\r\n        return this;\r\n    }\r\n\r\n    density(value) {\r\n        this._density = value;\r\n        return this;\r\n    }\r\n\r\n    persistence(value) {\r\n        this._persistence = value;\r\n        return this;\r\n    }\r\n\r\n    octaves(value) {\r\n        this._octaves = Math.max(1, value);\r\n        return this;\r\n    }\r\n\r\n    amplitude(value) {\r\n        this._amplitude = value;\r\n        return this;\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        this._base = this._base || new FastSimplexNoise({\r\n                min: -1,\r\n                max: 1,\r\n                frequency: 1 / this._density,\r\n                octaves: this._octaves,\r\n                amplitude: this._amplitude,\r\n                persistence: this._persistence,\r\n                random: function () {\r\n                    return hashRNG(this._seed, this._count++, 0);\r\n                }\r\n            });\r\n\r\n        const value = this._base.scaled2D(x, y);\r\n        const s = x + this._weight * value;\r\n        const t = y + this._weight * value;\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            seed: {\r\n                val: 1,\r\n                type: Type.INT,\r\n                min: 1,\r\n                max: 65535\r\n            },\r\n            density: {\r\n                val: 32,\r\n                min: EPSILON\r\n            },\r\n            amplitude: {\r\n                val: 1,\r\n                min: EPSILON,\r\n                max: 2\r\n            },\r\n            persistence: {\r\n                val: 0.5,\r\n                min: Number.EPSILON,\r\n                max: 2\r\n            },\r\n            octaves: {\r\n                val: 1,\r\n                min: 1,\r\n                type: Type.INT,\r\n                max: 8\r\n            },\r\n            weight: {\r\n                val: 4,\r\n                min: Number.EPSILON\r\n            }\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 4\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 128,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 1,\r\n                weight: 32\r\n            },\r\n            {\r\n                seed: 1,\r\n                density: 32,\r\n                amplitude: 0.5,\r\n                persistence: 0.75,\r\n                octaves: 1,\r\n                weight: 32\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {ColorInterpolator, ColorInterpolatorMethod} from '../../utils/ColorInterpolator';\r\n\r\nexport class GradientMap extends Program {\r\n    repeat(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setRepeat(value);\r\n        return this;\r\n    }\r\n\r\n    interpolation(value) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.setInterpolation(value);\r\n        return this;\r\n    }\r\n\r\n    point(position, color) {\r\n        this._gradient = this._gradient || new ColorInterpolator();\r\n        this._gradient.addPoint(position, color);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const v = src.getPixelNearest(x, y);\r\n\r\n        const r = this._gradient.getColorAt(v[0])[0];\r\n        const g = this._gradient.getColorAt(v[1])[1];\r\n        const b = this._gradient.getColorAt(v[2])[2];\r\n\r\n        color[0] = r;\r\n        color[1] = g;\r\n        color[2] = b;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            repeat: {\r\n                val: true,\r\n                type: Type.BOOLEAN\r\n            },\r\n            interpolation: {\r\n                val: 1,\r\n                type: Type.INTERPOLATION\r\n            },\r\n            point: {\r\n                val: null,\r\n                type: Type.COLOR_POINT\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Grayscale extends Program {\r\n    run(color, x, y, src) {\r\n        const value = src.getPixelNearest(x, y);\r\n        const g = .2126 * value[0] + .7152 * value[1] + .0722 * value[2];\r\n        color[0] = g;\r\n        color[1] = g;\r\n        color[2] = g;\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Normalize extends Program {\r\n    multiplier(value) {\r\n        this._multiplier = value;\r\n        return this;\r\n    }\r\n\r\n    offset(value) {\r\n        this._offset = value;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        if (!this._init) {\r\n            let high = -Infinity;\r\n            let low = Infinity;\r\n\r\n            let j = 0;\r\n            const len = src.array.length;\r\n            for (; j < len; j++) {\r\n                if (j % 4 === 3) continue;\r\n\r\n                high = ( src.array[j] > high ) ? src.array[j] : high;\r\n                low = ( src.array[j] < low  ) ? src.array[j] : low;\r\n            }\r\n\r\n            this._offset = -low;\r\n            this._multiplier = 1 / ( high - low );\r\n            this._init = true;\r\n        }\r\n\r\n        const v = src.getPixelNearest(x, y);\r\n        color[0] = ( v[0] + this._offset ) * this._multiplier;\r\n        color[1] = ( v[1] + this._offset ) * this._multiplier;\r\n        color[2] = ( v[2] + this._offset ) * this._multiplier;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            multiplier: {\r\n                val: 1\r\n            },\r\n            offset: {\r\n                val: 0\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\n\r\nexport class Pixelate extends Program {\r\n    constructor() {\r\n        super(Pixelate);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const s = this._size[0] * Math.floor(x / this._size[0]);\r\n        const t = this._size[1] * Math.floor(y / this._size[1]);\r\n\r\n        color.set(src.getPixelNearest(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {\r\n                val: [2, 2],\r\n                type: Type.INT,\r\n                min: 2,\r\n                max: 256\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\n\r\nexport class Posterize extends Program {\r\n    constructor() {\r\n        super(Posterize);\r\n    }\r\n\r\n    step(value) {\r\n        this._step = Math.max(value, 2);\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const v = src.getPixelNearest(x, y);\r\n        color[0] = Math.floor(Math.floor(v[0] * 255 / ( 255 / this._step )) * 255 / ( this._step - 1 )) / 255;\r\n        color[1] = Math.floor(Math.floor(v[1] * 255 / ( 255 / this._step )) * 255 / ( this._step - 1 )) / 255;\r\n        color[2] = Math.floor(Math.floor(v[2] * 255 / ( 255 / this._step )) * 255 / ( this._step - 1 )) / 255;\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            step: {\r\n                val: 2\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {EPSILON, Program} from '../../core/Program';\r\n\r\nexport class SineDistort extends Program {\r\n    constructor() {\r\n        super(SineDistort);\r\n    }\r\n\r\n    size(x, y) {\r\n        this._size = [Math.max(Number.EPSILON, x) / Math.PI / 2, Math.max(Number.EPSILON, y) / Math.PI / 2];\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    amplitude(x, y) {\r\n        this._amplitude = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        const s = x + Math.sin(y / this._size[0] + this._offset[0]) * this._amplitude[0];\r\n        const t = y + Math.sin(x / this._size[1] + this._offset[1]) * this._amplitude[1];\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            size: {val: [32, 32], min: EPSILON},\r\n            offset: {val: [0, 0]},\r\n            amplitude: {val: [8, 8], min: EPSILON}\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                size: [128, 128],\r\n                offset: [0, 0],\r\n                amplitude: [64, 64],\r\n            },\r\n            {\r\n                size: [256, 256],\r\n                offset: [0, 0],\r\n                amplitude: [32, 32],\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\nimport {deg2rad} from '../../utils/deg2rad';\r\n\r\nexport class Transform extends Program {\r\n    constructor() {\r\n        super(Transform);\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    angle(value) {\r\n        this._angle = deg2rad(value);\r\n        return this;\r\n    }\r\n\r\n    scale(x, y) {\r\n        if (x === 0 || y === 0) return;\r\n        this._scale = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src, width, height) {\r\n        const x2 = x - width / 2;\r\n        const y2 = y - height / 2;\r\n\r\n        let s = x2 * ( Math.cos(this._angle) / this._scale[0] ) + y2 * -( Math.sin(this._angle) / this._scale[0] );\r\n        let t = x2 * ( Math.sin(this._angle) / this._scale[1] ) + y2 * ( Math.cos(this._angle) / this._scale[1] );\r\n\r\n        s += this._offset[0] + width / 2;\r\n        t += this._offset[1] + height / 2;\r\n\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {val: [0, 0]},\r\n            angle: {val: 0, min: 0, max: 360},\r\n            scale: {val: [1, 1]}\r\n        };\r\n    }\r\n\r\n    static get examples() {\r\n        return [\r\n            {\r\n                offset: [0, 0],\r\n                angle: 45,\r\n                scale: [2, 2]\r\n            }\r\n        ];\r\n    }\r\n}\r\n","import {Program} from '../../core/Program';\r\nimport {distance} from '../../utils/distance';\r\n\r\nexport class Twirl extends Program {\r\n    constructor() {\r\n        super(Twirl);\r\n    }\r\n\r\n    weight(value) {\r\n        this._weight = value;\r\n        return this;\r\n    }\r\n\r\n    size(value) {\r\n        this._size = value;\r\n        return this;\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        let dist = distance(x, y, this._offset[0], this._offset[1]);\r\n        let s, t;\r\n\r\n        // no distortion if outside of whirl size.\r\n        if (dist < this._size) {\r\n            dist = Math.pow(this._size - dist, 2) / this._size;\r\n\r\n            const angle = 2.0 * Math.PI * (dist / (this._size / this._weight));\r\n            s = (((x - this._offset[0]) * Math.cos(angle)) - ((y - this._offset[0]) * Math.sin(angle)) + this._offset[0] + 0.5);\r\n            t = (((y - this._offset[1]) * Math.cos(angle)) + ((x - this._offset[1]) * Math.sin(angle)) + this._offset[1] + 0.5);\r\n        } else {\r\n            s = x;\r\n            t = y;\r\n        }\r\n\r\n        color.set(src.getPixelBilinear(s, t));\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            weight: {\r\n                val: 0.5,\r\n                min: -1,\r\n                max: 1\r\n            },\r\n            size: {\r\n                val: 128\r\n            },\r\n            offset: {\r\n                val: [128, 128]\r\n            }\r\n        };\r\n    }\r\n}\r\n","import {Program, Type} from '../../core/Program';\r\nimport {mirroredWrap, wrap} from '../../utils/wrap';\r\nimport {clamp} from '../../utils/clamp';\r\n\r\nexport class PutTexture extends Program {\r\n    constructor() {\r\n        super(PutTexture);\r\n    }\r\n\r\n    offset(x, y) {\r\n        this._offset = [x, y];\r\n        return this;\r\n    }\r\n\r\n    repeat(value) {\r\n        this._repeat = value;\r\n        return this;\r\n    }\r\n\r\n    texture(value) {\r\n        this._srcTex = value.buffer;\r\n        return this;\r\n    }\r\n\r\n    run(color, x, y, src) {\r\n        this._srcTex = this._srcTex || src;\r\n        const texWidth = this._srcTex.width;\r\n        const texHeight = this._srcTex.height;\r\n\r\n        const texX = Math.floor(x - this._offset[0]);\r\n        const texY = Math.floor(y - this._offset[1]);\r\n\r\n        if (texX >= texWidth || texY >= texHeight || texX < 0 || texY < 0) {\r\n            if (this._repeat) {\r\n                let nx, ny;\r\n                const rangeX = texWidth - 1;\r\n                const rangeY = texHeight - 1;\r\n\r\n                if (this._repeat === 1) {\r\n                    nx = wrap(texX, 0, texWidth);\r\n                    ny = wrap(texY, 0, texHeight);\r\n                } else if (this._repeat === 2) {\r\n                    nx = mirroredWrap(texX, 0, rangeX);\r\n                    ny = mirroredWrap(texY, 0, rangeY);\r\n                } else if (this._repeat === 3) {\r\n                    nx = clamp(texX, 0, rangeX);\r\n                    ny = clamp(texY, 0, rangeY);\r\n                }\r\n\r\n                color.set(this._srcTex.getPixelNearest(nx, ny));\r\n            } else {\r\n                color[0] = 0;\r\n                color[1] = 0;\r\n                color[2] = 0;\r\n            }\r\n        } else {\r\n            color.set(this._srcTex.getPixelNearest(texX, texY));\r\n        }\r\n    }\r\n\r\n    static get params() {\r\n        return {\r\n            offset: {\r\n                val: [0, 0]\r\n            },\r\n            repeat: {\r\n                val: false,\r\n                type: Type.BOOLEAN\r\n            },\r\n            texture: {\r\n                val: null,\r\n                type: Type.TEXTURE\r\n            }\r\n        };\r\n    }\r\n}\r\n","import * as Generators from './generators/index';\r\nimport * as Filters from './filters/index';\r\nimport * as Mixers from './mixers/index';\r\n\r\nexport const Programs = {\r\n    Generators: Generators,\r\n    Filters: Filters,\r\n    Mixers: Mixers\r\n};\r\n","export {Texture} from './core/Texture';\r\nexport {Buffer} from './core/Buffer';\r\nexport {Program, Type, EPSILON} from './core/Program';\r\n\r\nexport {ColorInterpolatorMethod} from './utils/ColorInterpolator';\r\n\r\nexport * from './programs/generators/index';\r\nexport * from './programs/filters/index';\r\nexport * from './programs/mixers/index';\r\n\r\nimport * as operations from './operations/index';\r\nexport const Operations = operations;\r\nexport {Programs} from './programs/index';\r\n\r\nexport {bufferToCanvas} from './utils/bufferToCanvas';\r\n\r\nexport const version = '2.0.0';\r\n"],"names":["set","x","y","add","sub","mul","div","and","xor","min","Math","max","average","a","b","screen","overlay","linearBurn","colorBurn","colorDodge","difference","abs","exclusion","softLight","hardLight","vividLight","linearLight","pinLight","mixColors","c1","c2","delta","wrap","value","v","r","mirroredWrap","clamp","distance","x0","y0","x1","y1","dx","dy","sqrt","smoothStep","edge0","edge1","xx","hashRNG","seed","s","cellNoiseBase","density","weight","qx","qy","rx","ry","w","px","py","dist","shortest","Infinity","sx","sy","ceil","deg2rad","deg","dr","bufferToCanvas","buffer","width","height","canvas","can","document","createElement","ctx","getContext","imageData","getImageData","data","heap","Uint8Array","last","length","i","putImageData","Buffer","array","Float32Array","color","_x","round","_y","this","offset","floor","p0","fx","fy","fx1","fy1","w1","w2","w3","w4","p1","p2","p3","p4","len","parseInt","Texture","bufferCopy","context","createImageData","il","undefined","toImageData","program","operation","copy","op","dst","src","tint","run","ArrayBuffer","res","Uint8ClampedArray","l","o","prototype","operations","Program","proto","_tint","1","2","3","params","keys","forEach","p","val","Array","isArray","apply","call","g","arguments","Type","EPSILON","Number","ColorInterpolatorMethod","ColorInterpolator","method","points","low","high","interpolation","LINEAR","repeat","sort","pos","position","push","STEP","SPLINE","ar","br","ag","bg","dg","ab","bb","db","delta2","delta3","SinX","_size","PI","_offset","sin","SinY","Or","Xor","Rect","Circle","_delta","CheckerBoard","_shift","LinearGradient","size","_gradient","setRepeat","setInterpolation","addPoint","getColorAt","BOOLEAN","INTERPOLATION","COLOR_POINT","RadialGradient","Noise","_seed","INT","NoiseFractal","_baseFrequency","_amplitude","_persistence","_octaves","_step","_interpolator","amp","freq","v1","v2","v3","v4","i1","i2","j","CellularNoise","_density","_weight","CellularFractal","_scale","dens","VoronoiNoise","VoronoiFractal","FastSimplexNoise","options","hasOwnProperty","amplitude","frequency","octaves","persistence","random","scale","n","q","perm","permMod12","gs","coords","slice","reduce","total","t","G2","X0","Y0","j1","x2","y2","ii","jj","gi0","gi1","gi2","t0","n0","pow","dot","GRAD3D","t1","n1","t2","n2","maxAmplitude","noise","raw2D","SimplexNoise","_count","_base","scaled2D","Abs","getPixelNearest","Copy","Convolution","_weights","Presets","_side","_halfSide","cy","cx","scy","scx","wt","Distort","getPixelBilinear","GradientMap","Grayscale","Normalize","_multiplier","_init","Pixelate","Posterize","SineDistort","Transform","_angle","cos","Twirl","angle","PutTexture","_repeat","_srcTex","texWidth","texHeight","texX","texY","nx","ny","rangeX","rangeY","TEXTURE","Programs","Generators","Filters","Mixers","Operations","version"],"mappings":"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"}